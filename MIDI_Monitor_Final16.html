<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATHEDRAL COMMANDER // MK XX</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@500;700&family=VT323&family=Nosifer&family=Playfair+Display:wght@700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- CORE VARIABLES --- */
        :root {
            --bg-color: #050505;
            --panel-bg: #0a0a0a;
            --text-color: #00ff41;
            --accent-color: #ff0055;
            --data-color: #00ccff;
            --grid-beat: #222;
            --grid-bar: #666;
            --font-stack: 'Rajdhani', sans-serif;
            --font-size-base: 13px;
            --cc-graph-width: 150px;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: var(--font-size-base);
            transition: background 0.3s, color 0.3s;
        }

        /* --- HEADER --- */
        header {
            height: 50px;
            background: var(--panel-bg);
            border-bottom: 2px solid var(--text-color);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            z-index: 20;
            flex-shrink: 0;
            justify-content: space-between;
            transition: background 0.3s, border 0.3s;
        }

        h1 {
            margin: 0; font-size: calc(var(--font-size-base) * 1.4); letter-spacing: 3px;
            color: var(--accent-color); font-weight: 700; white-space: nowrap;
            text-transform: uppercase;
        }

        .header-left, .header-right { display: flex; align-items: center; gap: 10px; }

        /* CONTROLS */
        select, button, input[type=number] {
            background: #000; color: var(--text-color); border: 1px solid #333;
            padding: 4px 8px; font-family: var(--font-stack); font-size: var(--font-size-base);
            text-transform: uppercase; cursor: pointer; letter-spacing: 1px;
            outline: none;
        }
        /* Fix Dropdown Border Color */
        select { border-color: var(--text-color); }

        button:hover, select:hover { background: #222; border-color: var(--text-color); }
        button.active { background: var(--text-color); color: #000; font-weight: bold; box-shadow: 0 0 10px var(--text-color); }
        button.icon-btn { font-size: calc(var(--font-size-base) * 1.2); padding: 2px 8px; }

        .control-group {
            display: flex; flex-direction: column; justify-content: center;
            border-right: 1px solid #333; padding-right: 15px; height: 36px;
        }
        .control-group.no-border { border: none; }

        /* SLIDERS */
        .range-wrap { display: flex; flex-direction: column; gap: 2px; }
        .range-wrap label { font-size: calc(var(--font-size-base) * 0.7); color: #666; letter-spacing: 1px; }
        input[type=range] {
            width: 100px; height: 4px; background: #333; appearance: none; cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            appearance: none; width: 10px; height: 10px; background: var(--text-color);
        }

        /* --- SETTINGS PANEL --- */
        #settings-panel {
            position: absolute; top: 50px; left: 0; width: 100%;
            background: var(--panel-bg); border-bottom: 2px solid var(--text-color);
            padding: 15px; display: none; z-index: 19;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.8);
            max-height: calc(100vh - 60px); overflow-y: auto;
        }
        #settings-panel.open { display: grid; }

        .setting-col { display: flex; flex-direction: column; gap: 8px; }
        .setting-col h3 { margin: 0 0 5px 0; font-size: var(--font-size-base); color: var(--accent-color); border-bottom: 1px solid #333; padding-bottom: 2px;}
        .setting-row { display: flex; justify-content: space-between; align-items: center; }
        .setting-row label { font-size: calc(var(--font-size-base) * 0.9); color: #aaa; }

        .sig-inputs { display: flex; gap: 5px; align-items: center; }
        .sig-inputs input { width: 40px; text-align: center; }

        /* --- WORKSPACE LAYOUT --- */
        .workspace {
            display: flex; flex-grow: 1; height: calc(100vh - 50px); position: relative;
            overflow: hidden;
            /* Default: Sidebar on Right */
            flex-direction: row;
        }
        .workspace.sidebar-bottom { flex-direction: column; }

        /* VISUALIZER WRAPPER */
        .vis-wrapper {
            flex-grow: 1; position: relative; display: flex;
            overflow: hidden; background: #000;
            flex-direction: column; /* Default Vertical */
        }

        /* Directional Layouts */
        .workspace.dir-down .vis-wrapper { flex-direction: column; }
        .workspace.dir-up .vis-wrapper { flex-direction: column-reverse; }
        .workspace.dir-right .vis-wrapper { flex-direction: row; }
        .workspace.dir-left .vis-wrapper { flex-direction: row-reverse; }

        /* PIANO ROLL */
        #piano-roll-header {
            background: var(--panel-bg); flex-shrink: 0; display: none;
            border-style: solid; border-color: #333; border-width: 0;
        }
        #piano-roll-header.visible { display: block; }

        .workspace.dir-down #piano-roll-header { width: 100%; height: 30px; border-bottom-width: 1px; }
        .workspace.dir-up #piano-roll-header { width: 100%; height: 30px; border-top-width: 1px; }
        .workspace.dir-right #piano-roll-header { width: 40px; height: 100%; border-right-width: 1px; }
        .workspace.dir-left #piano-roll-header { width: 40px; height: 100%; border-left-width: 1px; }

        /* CANVAS */
        #visualizer-container { flex-grow: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* --- SIDEBAR (CC) --- */
        #sidebar {
            background: var(--panel-bg); border-color: var(--text-color); border-style: solid; border-width: 0;
            display: none; flex-direction: column; flex-shrink: 0; z-index: 15; position: relative;
        }
        #sidebar.visible { display: flex; }

        .workspace:not(.sidebar-bottom) #sidebar { width: 300px; border-left-width: 2px; }
        .workspace.sidebar-bottom #sidebar { height: 200px; width: 100%; border-top-width: 2px; }

        .resizer { position: absolute; z-index: 20; background: rgba(255,255,255,0.05); }
        .resizer:hover { background: var(--accent-color); }

        .workspace:not(.sidebar-bottom) .resizer { width: 5px; cursor: col-resize; left: 0; top: 0; bottom: 0; }
        .workspace.sidebar-bottom .resizer { height: 5px; cursor: row-resize; top: 0; left: 0; right: 0; }

        .sidebar-header {
            padding: 8px; background: rgba(0,0,0,0.2); font-weight: 700;
            border-bottom: 1px solid #333; letter-spacing: 1px;
            display: flex; justify-content: space-between; align-items: center;
        }

        .sidebar-content {
            flex-grow: 1; overflow-y: auto; padding: 5px;
            display: flex; flex-direction: column; gap: 4px;
        }

        /* Bottom Layout for Sidebar */
        .workspace.sidebar-bottom .sidebar-content {
            flex-direction: row; flex-wrap: wrap; align-content: flex-start;
            overflow-x: auto; /* Allow scroll if needed */
        }

        /* CC WIDGETS */
        .cc-widget {
            background: rgba(0,0,0,0.3); border: 1px solid #333; padding: 0 5px;
            display: flex; align-items: center; height: 40px; gap: 8px;
            animation: flashCC 0.1s ease-out;
            flex-shrink: 0; /* Prevent shrinking in row mode */
            min-width: 120px; /* Hard stop shrinking */
        }
        .cc-widget.hidden { display: none; }
        @keyframes flashCC { from { background: #222; } to { background: rgba(0,0,0,0.3); } }

        .cc-meta { width: 70px; display: flex; flex-direction: column; gap: 2px; pointer-events: none; }
        .cc-label { font-size: calc(var(--font-size-base) * 0.7); color: #666; }
        .cc-name { font-size: calc(var(--font-size-base) * 0.8); font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cc-val-big {
            font-size: calc(var(--font-size-base) * 1.1); color: var(--data-color); font-weight: 700; font-family: monospace;
            width: 35px; text-align: right; flex-shrink: 0; /* Jitter Fix */
        }
        .cc-graph-container {
            flex-grow: 1; height: 30px; background: #000; border: 1px solid #222; position: relative;
            cursor: pointer; /* Click to rename */
            min-width: 50px; /* Prevent total collapse */
        }

        /* Bottom Layout Fixed Width Graphs */
        .workspace.sidebar-bottom .cc-graph-container {
            width: var(--cc-graph-width, 150px);
            flex-grow: 0; flex-shrink: 0;
        }

        .cc-bg-label {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: rgba(255,255,255,0.1); font-weight: 900; pointer-events: none;
            white-space: nowrap;
        }

        .cc-pin-btn {
            width: 12px; height: 12px; border: 1px solid #666; border-radius: 50%;
            cursor: pointer; margin-left: auto;
        }
        .cc-pin-btn.active { background: var(--accent-color); border-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-color); }

        /* CHANNEL MATRIX */
        .ch-matrix { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; width: 200px; display: none; }
        .ch-matrix.visible { display: grid; }
        .ch-led {
            height: 14px; background: #111; border: 1px solid #333;
            font-size: calc(var(--font-size-base) * 0.7); /* Scale Font */
            display: flex; align-items: center; justify-content: center; color: #444;
            transition: background 0.1s, box-shadow 0.1s;
        }

        /* STATUS & BPM */
        #status-box { display: flex; align-items: center; gap: 10px; border: 1px solid #333; padding: 0 10px; height: 30px; }
        #transport-val { font-weight: bold; color: #555; width: 40px; text-align: center; font-size: calc(var(--font-size-base) * 0.9); }
        #bpm-box { display: flex; align-items: center; gap: 5px; }
        #bpm-val { color: var(--accent-color); font-weight: bold; font-size: calc(var(--font-size-base) * 1.2); width: 50px; text-align:right;}
        .bpm-label { font-size: calc(var(--font-size-base) * 0.7); color: #666; }
        #clock-dot { width: 6px; height: 6px; background: #333; border-radius: 50%; }
        #clock-dot.beat { background: var(--text-color); box-shadow: 0 0 8px var(--text-color); }

        /* CRT SCANLINES */
        .crt-scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0) 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10; opacity: 0;
            display: block; /* Always block, opacity controls visibility */
        }
    </style>
</head>
<body>
<header>
    <div class="header-left">
        <h1 id="app-title">MK XX</h1>

        <div class="control-group">
            <select id="midi-input" style="min-width: 150px;"><option>INIT SYSTEMS...</option></select>
        </div>

        <div id="status-box">
            <span id="transport-val">STOP</span>
            <div style="width:1px; height:15px; background:#333" id="transport-div"></div>
            <div id="bpm-box">
                <div id="clock-dot"></div>
                <span id="bpm-val">NO CLOCK</span>
                <span class="bpm-label">BPM</span>
            </div>
        </div>

        <button id="btn-toggle-cc" class="icon-btn active">CC</button>
        <button id="btn-toggle-pgm" class="icon-btn active">PGM</button>
        <button id="btn-toggle-split" class="icon-btn" title="Per-Channel Split Mode">SPLIT</button>

        <div class="ch-matrix visible" id="ch-matrix">
            <!-- JS GEN -->
        </div>
    </div>

    <div class="header-right">
        <!-- QUICK CONTROLS -->
        <div class="range-wrap">
            <label>ZOOM</label>
            <input type="range" id="zoom-slider" min="1" max="8" step="0.1" value="1">
        </div>
        <div class="range-wrap">
            <label>POS</label>
            <input type="range" id="pan-slider" min="0" max="100" step="1" value="30">
        </div>

        <button id="btn-settings" class="icon-btn" style="font-size: 20px;">&#9881;</button>
    </div>
</header>

<!-- SETTINGS PANEL -->
<div id="settings-panel">
    <!-- COL 1: VISUAL FLAVOUR -->
    <div class="setting-col">
        <h3>VISUAL FLAVOUR</h3>
        <div class="setting-row">
            <label>THEME</label>
            <select id="sel-theme">
                <option value="matrix">MATRIX (STD)</option>
                <option value="crave">CRAVE (ORANGE)</option>
                <option value="masseffect">MASS EFFECT N7</option>
                <option value="synthwave">SYNTHWAVE</option>
                <option value="neon">NEON NIGHTS</option>
                <option value="chernobyl">CHERNOBYL (RAD)</option>
                <option value="mono">MONOCHROME</option>
                <option value="warhammer">WARHAMMER 40K</option>
                <option value="helldiver">HELLDIVERS 2</option>
                <option value="elektron">ELEKTRON</option>
                <option value="oxi">OXI INSTRUMENTS</option>
                <option value="sanctuary">SANCTUARY (DIABLO)</option>
                <option value="kerbal">KERBAL SPACE PROGRAM</option>
                <option value="accordion">ACCORDION</option>
                <option value="neve">NEVE CONSOLE</option>
            </select>
        </div>
        <div class="setting-row">
            <label>FONT</label>
            <select id="sel-font">
                <option value="tech">DIN / TECH</option>
                <option value="elegant">IMPERIAL (PLAYFAIR)</option>
                <option value="hacker">TERMINAL</option>
                <option value="gory">GORY (NOSIFER)</option>
                <option value="scifi">SCI-FI (ORBITRON)</option>
                <option value="system">SYSTEM</option>
            </select>
        </div>
        <div class="setting-row">
            <label>NOTE COLOR</label>
            <div style="display:flex; gap:4px;">
                <button id="btn-shuffle-notes" class="icon-btn" title="Shuffle Colors">R</button>
                <select id="sel-color-mode" style="width:80px;">
                    <option value="channel">CHANNEL</option>
                    <option value="octave">OCTAVE</option>
                    <option value="root">ROOT</option>
                    <option value="random">RANDOM</option>
                </select>
            </div>
        </div>
        <div class="setting-row">
            <label>CC COLOR</label>
            <div style="display:flex; gap:4px;">
                <button id="btn-shuffle-cc" class="icon-btn" title="Shuffle Colors">R</button>
                <select id="sel-cc-color-mode" style="width:80px;">
                    <option value="match">MATCH</option>
                    <option value="white">WHITE</option>
                    <option value="matrix">MATRIX</option>
                    <option value="crave">CRAVE</option>
                    <option value="masseffect">MASS EFFECT</option>
                    <option value="synthwave">SYNTHWAVE</option>
                    <option value="neon">NEON</option>
                    <option value="chernobyl">CHERNOBYL</option>
                    <option value="mono">MONO</option>
                    <option value="warhammer">WARHAMMER</option>
                    <option value="helldiver">HELLDIVER</option>
                    <option value="elektron">ELEKTRON</option>
                    <option value="oxi">OXI</option>
                    <option value="sanctuary">SANCTUARY</option>
                    <option value="kerbal">KERBAL</option>
                    <option value="accordion">ACCORDION</option>
                    <option value="neve">NEVE</option>
                    <option value="random">RANDOM</option>
                </select>
            </div>
        </div>
        <div class="setting-row">
            <label>NOTE SHAPE</label>
            <select id="sel-shape">
                <option value="bar">BAR</option>
                <option value="bubble">BUBBLE</option>
                <option value="tear">TEARDROP</option>
                <option value="hex">HEX</option>
            </select>
        </div>
        <div class="setting-row"><label>NOTE WIDTH</label><input type="range" id="thick-slider" min="10" max="200" value="100"></div>
        <div class="setting-row"><label>GLOW ON</label><input type="checkbox" id="chk-glow"></div>
        <div class="setting-row"><label>GLOW AMT</label><input type="range" id="glow-slider" min="0" max="50" value="15"></div>
        <div class="setting-row"><label>BIG CC GLOW</label><input type="checkbox" id="chk-cc-glow"></div>
        <div class="setting-row"><label>BIG CC OPAC</label><input type="range" id="cc-opac-slider" min="0.1" max="1" step="0.1" value="0.6"></div>
        <div class="setting-row"><label>TRAILS</label><input type="range" id="persist-slider" min="0" max="0.9" step="0.01" value="0"></div>
        <div class="setting-row"><label>OVL TRAIL</label><input type="checkbox" id="chk-ovl-trail"></div>
        <div class="setting-row"><label>CRT FX</label><input type="range" id="crt-slider" min="0" max="1" step="0.1" value="0"></div>
        <div class="setting-row"><label>FRESH LABELS</label><input type="checkbox" id="chk-fresh-labels"></div>
        <div class="setting-row"><label>FRESH PGM</label><input type="checkbox" id="chk-fresh-pgm"></div>
        <div class="setting-row"><label>VEL OPACITY</label>
            <div style="display:flex; align-items:center; gap:5px;">
                <input type="checkbox" id="chk-vel-opacity">
                <input type="range" id="vel-opac-base-slider" min="0" max="100" value="30" style="width:60px;" title="Min Opacity %">
            </div>
        </div>
    </div>

    <!-- COL 2: DATA DISPLAY -->
    <div class="setting-col">
        <h3>DATA DISPLAY</h3>
        <div class="setting-row"><label>SHOW LABELS</label><input type="checkbox" id="chk-labels"></div>
        <div class="setting-row"><label>LABEL PER BAR</label><input type="checkbox" id="chk-lbl-per-bar"></div>
        <div class="setting-row"><label>LABEL SIZE</label><input type="range" id="lbl-size-slider" min="8" max="32" value="13"></div>
        <div class="setting-row">
            <label>LABEL COL</label>
            <select id="sel-lbl-col">
                <option value="white">WHITE</option>
                <option value="match">MATCH THEME</option>
            </select>
        </div>
    </div>

    <!-- COL 3: OVERLAY & LAYOUT -->
    <div class="setting-col">
        <h3>OVERLAY & LAYOUT</h3>
        <div class="setting-row"><label>UI SIZE</label><input type="range" id="font-size-slider" min="10" max="32" value="13"></div>
        <div class="setting-row">
            <label>CC SIZE</label>
            <div style="display:flex; gap:5px; align-items:center;">
                <input type="range" id="cc-size-slider" min="8" max="24" value="14" style="width:70px;">
                <button id="btn-sync-fonts" class="icon-btn" title="Sync to UI Size">=</button>
            </div>
        </div>
        <div class="setting-row"><label>CC SCALE</label><input type="range" id="cc-scale-slider" min="100" max="300" value="150"></div>
        <div class="setting-row"><label>BAR THICK</label><input type="range" id="grid-thick" min="1" max="8" value="2"></div>
        <div class="setting-row"><label>SPEED</label><input type="range" id="speed-slider" min="1" max="10" value="4"></div>
        <div class="setting-row"><label>OVL SMOOTH</label><input type="range" id="ovl-smooth-slider" min="0" max="100" value="0"></div>
        <div class="setting-row"><label>OVL THICK</label><input type="range" id="ovl-thick-slider" min="1" max="20" value="3"></div>
        <div class="setting-row"><label>DIRECTION</label>
            <select id="sel-direction">
                <option value="down">DOWN (WATERFALL)</option>
                <option value="up">UP (RISING)</option>
                <option value="right">RIGHT (TIMELINE)</option>
                <option value="left">LEFT (REWIND)</option>
            </select>
        </div>
        <div class="setting-row"><label>CC POS</label>
            <select id="sel-sidebar-pos">
                <option value="right">RIGHT SIDE</option>
                <option value="bottom">BOTTOM</option>
            </select>
        </div>
        <div class="setting-row"><label>CC DIRECTION</label>
            <select id="sel-cc-dir">
                <option value="left">SCROLL LEFT</option>
                <option value="right">SCROLL RIGHT</option>
            </select>
        </div>
        <div class="setting-row"><label>TRAILS ON GRID</label><input type="checkbox" id="chk-trails-grid"></div>
        <div class="setting-row"><label>CC GRID</label><input type="checkbox" id="chk-cc-grid"></div>
    </div>

    <!-- COL 4: SYSTEM & FLIGHT -->
    <div class="setting-col">
        <h3>SYSTEM</h3>
        <div class="setting-row">
            <button id="btn-manual-init" style="width: 100%; color: var(--accent-color);">[ MANUAL INIT MIDI ]</button>
        </div>
        <div class="setting-row">
            <button id="btn-save-cfg" style="width: 48%;">SAVE CFG</button>
            <button id="btn-load-cfg" style="width: 48%;">LOAD CFG</button>
            <input type="file" id="file-input" style="display:none" accept=".json">
        </div>
        <div class="setting-row">
            <button id="btn-save-db" style="width: 48%;">SAVE DB</button>
            <button id="btn-load-db" style="width: 48%;">LOAD DB</button>
            <input type="file" id="db-input" style="display:none" accept=".json">
        </div>

        <h3>FLIGHT DATA</h3>
        <div class="setting-row"><label>SHOW PGM</label><input type="checkbox" id="chk-show-pgm" checked></div>
        <div class="setting-row"><label>TIME SIG</label>
            <div class="sig-inputs">
                <input type="number" id="sig-num" value="4" min="1" max="32"><span>/</span><input type="number" id="sig-den" value="4" min="1" max="32">
            </div>
        </div>
        <div class="setting-row"><label>CC TIMEOUT</label>
            <select id="sel-cc-timeout">
                <option value="0">NEVER</option>
                <option value="2000">2 SEC</option>
                <option value="5000">5 SEC</option>
                <option value="10000">10 SEC</option>
                <option value="60000">60 SEC</option>
            </select>
        </div>
        <div class="setting-row"><label>SHOW SYNC</label><input type="checkbox" id="chk-bpm" checked></div>
        <div class="setting-row"><label>SHOW CC</label><input type="checkbox" id="chk-cc-panel" checked></div>
        <div class="setting-row"><label>SHOW PIANO</label><input type="checkbox" id="chk-piano" checked></div>
        <div class="setting-row"><label>SHOW MATRIX</label><input type="checkbox" id="chk-matrix" checked></div>
        <div class="setting-row"><label>SHOW GRID</label><input type="checkbox" id="chk-grid" checked></div>
        <div class="setting-row"><label>SHOW BARS</label><input type="checkbox" id="chk-bar" checked></div>
        <div class="setting-row"><label>SHOW C-LINES</label><input type="checkbox" id="chk-clines"></div>

        <h3>NOTE CHANNELS</h3>
        <div class="ch-filter-grid" id="ch-filter-container-notes" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px;"></div>
        <h3>CC CHANNELS</h3>
        <div class="ch-filter-grid" id="ch-filter-container-cc" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px;"></div>
        <h3>SPLIT CHANNELS</h3>
        <div class="ch-filter-grid" id="ch-filter-container-split" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px;"></div>
    </div>
</div>

<div class="workspace dir-down" id="main-workspace">

    <div class="vis-wrapper" id="vis-wrapper">
        <div id="piano-roll-header" class="visible">
            <canvas id="pianoCanvas"></canvas>
        </div>
        <div id="visualizer-container">
            <div class="crt-scanlines" id="crt-overlay"></div>
            <canvas id="mainCanvas"></canvas>
            <canvas id="overlayCanvas" style="pointer-events:none; position:absolute; top:0; left:0;"></canvas>
        </div>
    </div>

    <div id="sidebar" class="visible">
        <div class="resizer" id="drag-handle"></div>
        <div class="sidebar-header">
            <div style="display:flex; flex-direction:column;">
                <span>CC FLIGHT RECORDER</span>
                <span style="font-size:9px; color:#666; font-weight:normal;">R-CLICK HIDE / DRAG OVL</span>
            </div>
            <div style="display:flex; gap:2px;">
                <button class="icon-btn" onclick="resetCCFilters()" title="Show All">ALL</button>
                <button class="icon-btn" onclick="clearCC()" title="Clear Data">CLR</button>
            </div>
        </div>
        <div id="big-cc-controls" style="display: none; padding: 5px; border-bottom: 1px solid #333; background: #0a0a0a;">
             <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end;">
                <div class="range-wrap">
                    <label>SCALE</label>
                    <input type="range" id="big-cc-scale-slider" min="0.1" max="10" step="0.1" value="1" style="width:80px;">
                </div>
                <div class="range-wrap">
                    <label>DENSITY</label>
                    <input type="range" id="cc-grid-density-slider" min="1" max="127" step="1" value="16" style="width:80px;">
                </div>
                <div class="range-wrap">
                    <label>SMOOTH</label>
                    <input type="range" id="cc-smooth-slider" min="1" max="50" step="1" value="1" style="width:80px;">
                </div>
                <div style="display:flex; flex-direction:column; gap:2px;">
                    <button id="btn-cc-clamp" class="icon-btn" style="font-size:10px; width:60px;">CLAMP</button>
                    <button id="btn-cc-grid-toggle" class="icon-btn" style="font-size:10px; width:60px;">GRID</button>
                </div>
            </div>
        </div>
        <div class="sidebar-content" id="cc-container">
            <div style="text-align:center; color:var(--text-color); opacity:0.5; font-size:10px; padding-top:20px;">NO SIGNAL</div>
        </div>
    </div>

</div>
<script>
    /**
     * CATHEDRAL COMMANDER MK XX
     * "VIENNA VANGUARD" EDITION
     */

    // --- CONFIG ---
    const THEMES = {
        matrix: { bg:'#050505', panel:'#0a0a0a', text:'#00ff41', accent:'#ff0055', data:'#00ccff', grid:'#222', bar:'#666', ch:['#FF0055','#00FF41','#00CCFF','#FFCC00','#9900FF','#FF6600','#00FFCC','#FF3399','#EEE','#888','#B71C1C','#1B5E20','#33691E','#3E2723','#01579B','#4A148C']},
        crave: { bg:'#1a1a1a', panel:'#222', text:'#F57F17', accent:'#FFCC00', data:'#888', grid:'#333', bar:'#F57F17', ch:['#F57F17','#d1d1d1','#FFCC00','#a0a0a0','#F57F17','#d1d1d1','#FFCC00','#a0a0a0','#F57F17','#d1d1d1','#FFCC00','#a0a0a0','#F57F17','#d1d1d1','#FFCC00','#a0a0a0']},
        masseffect: { bg:'#0b1624', panel:'#131b29', text:'#4DB2FF', accent:'#D9531E', data:'#fff', grid:'#1c2b3d', bar:'#D9531E', ch:['#D9531E','#4DB2FF','#ffffff','#888888','#D9531E','#4DB2FF','#ffffff','#888888','#D9531E','#4DB2FF','#ffffff','#888888','#D9531E','#4DB2FF','#ffffff','#888888']},
        synthwave: { bg:'#12001f', panel:'#1e0033', text:'#00f2ff', accent:'#ff0099', data:'#bd00ff', grid:'#36005c', bar:'#ff0099', ch:['#ff0099','#00f2ff','#bd00ff','#faff00','#ff0099','#00f2ff','#bd00ff','#faff00','#ff0099','#00f2ff','#bd00ff','#faff00','#ff0099','#00f2ff','#bd00ff','#faff00']},
        neon: { bg:'#000', panel:'#000', text:'#0f0', accent:'#f0f', data:'#0ff', grid:'#333', bar:'#fff', ch:['#f00','#0f0','#00f','#ff0','#0ff','#f0f','#fff','#aaa','#f00','#0f0','#00f','#ff0','#0ff','#f0f','#fff','#aaa']},
        mono: { bg:'#000', panel:'#000', text:'#fff', accent:'#fff', data:'#fff', grid:'#333', bar:'#fff', ch:['#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff']},
        warhammer: { bg:'#0b0500', panel:'#1a0f00', text:'#d4af37', accent:'#8a0000', data:'#7a7a7a', grid:'#2b1d0e', bar:'#8a0000', ch:['#8a0000','#d4af37','#5e5e5e','#ffffff','#8a0000','#d4af37','#5e5e5e','#ffffff','#8a0000','#d4af37','#5e5e5e','#ffffff','#8a0000','#d4af37','#5e5e5e','#ffffff']},
        helldiver: { bg:'#111', panel:'#1a1a1a', text:'#ffe600', accent:'#fff', data:'#aaa', grid:'#333', bar:'#ffe600', ch:['#ffe600','#000','#fff','#ffe600','#333','#fff','#ffe600','#333','#fff','#ffe600','#333','#fff','#ffe600']},
        elektron: { bg:'#222', panel:'#333', text:'#ff6600', accent:'#ff3333', data:'#aaa', grid:'#444', bar:'#ff6600', ch:['#ff3333','#ff6600','#ffffff','#888','#ff3333','#ff6600','#ffffff','#888','#ff3333','#ff6600','#ffffff','#888','#ff3333','#ff6600','#ffffff','#888']},
        oxi: { bg:'#000', panel:'#111', text:'#fff', accent:'#00ffcc', data:'#ff00ff', grid:'#222', bar:'#fff', ch:['#ff99cc','#99ccff','#99ffcc','#ffff99','#cc99ff','#ffcc99','#fff','#888','#ff99cc','#99ccff','#99ffcc','#ffff99','#cc99ff','#ffcc99','#fff','#888']},
        lsd: { bg:'#000', panel:'#100020', text:'#00ff00', accent:'#ff00ff', data:'#00ffff', grid:'#222', bar:'#fff', ch:['#f00','#ff8000','#ff0','#80ff00','#0f0','#00ff80','#0ff','#0080ff','#00f','#8000ff','#f0f','#ff0080','#fff','#888','#444','#000']},
        sanctuary: { bg:'#050000', panel:'#1a0000', text:'#c20000', accent:'#ffcc00', data:'#590000', grid:'#220000', bar:'#8a0000', ch:['#8a0000','#ff2200','#ffcc00','#440000','#8a0000','#ff2200','#ffcc00','#440000','#8a0000','#ff2200','#ffcc00','#440000','#8a0000','#ff2200','#ffcc00','#440000']},
        kerbal: { bg:'#222', panel:'#333', text:'#BADA55', accent:'#fff', data:'#888', grid:'#444', bar:'#BADA55', ch:['#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55']},
        chernobyl: { bg:'#000000', panel:'#050505', text:'#00ffff', accent:'#0099ff', data:'#0055ff', grid:'#111', bar:'#00ffff', ch:['#0ff','#00ccff','#0099ff','#0066ff','#fff','#aaa','#0ff','#00ccff','#0099ff','#0066ff','#fff','#aaa','#0ff','#00ccff','#0099ff','#0066ff']},
        accordion: { bg:'#1a1510', panel:'#2b231a', text:'#e6dcc8', accent:'#8c2626', data:'#111', grid:'#3e3226', bar:'#e6dcc8', ch:['#e6dcc8','#111','#8c2626','#3e3226','#e6dcc8','#111','#8c2626','#3e3226','#e6dcc8','#111','#8c2626','#3e3226','#e6dcc8','#111','#8c2626','#3e3226']},
        neve: { bg:'#2a2f35', panel:'#353b42', text:'#aab2bd', accent:'#bf2e2e', data:'#2e5280', grid:'#444b54', bar:'#bf2e2e', ch:['#2e5280','#bf2e2e','#aab2bd','#2a2f35','#2e5280','#bf2e2e','#aab2bd','#2a2f35','#2e5280','#bf2e2e','#aab2bd','#2a2f35']}
    };

    const CONFIG = {
        NOTE_NAMES: ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
        BLACK_KEYS: [1, 3, 6, 8, 10],
        PPQN: 24
    };

    // --- STATE ---
    let midiAccess = null;
    let selectedInputId = null;

    let currentFontStack = "'Rajdhani', sans-serif";
    let currentTheme = 'matrix';
    let noteSpeed = 4;
    let zoomLevel = 1;
    let panPercent = 30;
    let colorMode = 'channel';
    let ccColorMode = 'match';
    let ccTimeout = 0;
    let showLabels = false;
    let showGrid = true;
    let showBarLines = true;
    let showPiano = true;
    let showCLines = false;
    let glowEnabled = false;
    let glowAmount = 15;
    let ccGlow = false;
    let ccOpacity = 0.6;
    let direction = 'down';
    let persistence = 0;
    let noteThickness = 100;
    let noteShape = 'bar';
    let fontSizeCC = 14;
    let ccScrollDir = 'left';
    let channelMaskNotes = new Array(16).fill(true);
    let channelMaskCC = new Array(16).fill(true);
    let channelMaskSplit = new Array(16).fill(true); // New mask for Split View
    let perChannelMode = false;
    let trailsOnGrid = false;
    let bigCCs = new Set();
    let hiddenCCs = new Set();
    let randomPaletteNotes = [];
    let randomPaletteCC = [];

    // New Features State
    let showPGM = true;
    let freshPGM = false;
    let freshLabels = false;
    let labelSize = 13;
    let labelColorMode = 'white';
    let labelPerBar = false;
    let overlaySmooth = 0;
    let overlayThick = 3;
    let overlayTrails = false;
    let ccScale = 1; // SCALE MULTIPLIER

    // MK21 Features
    let ccClamp = false;
    let ccGridDensity = 16;
    let ccSmoothWindow = 1;
    let velOpacityBase = 0.3; // 0.3 = 30% min opacity

    let sigNum = 4;
    let sigDen = 4;
    let barThickness = 2;
    let fontScale = 13;

    // Data
    const activeNotes = new Map();
    const fallingObjects = [];
    const ccMonitors = new Map();
    const chIndicators = [];
    const persistentLabels = new Map(); // Fix Label Loss
    const labeledPitches = new Set();
    const barLabels = new Set(); // Track pitches labeled in current bar

    // Clock
    let clockTicks = 0;
    let lastClockTime = 0;
    let tickHistory = [];
    let lastActiveClock = 0;
    let ticksPerBar = 96;
    let barTickCounter = 0;

    const mainCanvas = document.getElementById('mainCanvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const pianoCanvas = document.getElementById('pianoCanvas');
    const mainCtx = mainCanvas.getContext('2d', { alpha: true });
    const overlayCtx = overlayCanvas.getContext('2d', { alpha: true });
    const pianoCtx = pianoCanvas.getContext('2d', { alpha: false });
    const chContainer = document.getElementById('ch-matrix');

    function init() {
        shuffleColors(randomPaletteNotes);
        shuffleColors(randomPaletteCC);
        setupChannelMatrix();
        setupChannelFilters('ch-filter-container-notes', channelMaskNotes);
        setupChannelFilters('ch-filter-container-cc', channelMaskCC);
        setupChannelFilters('ch-filter-container-split', channelMaskSplit);
        setupEventListeners();
        applyTheme('matrix');
        updateTimeSig();
        updateFont('tech'); // Default to DIN/Tech
        resize();
        window.addEventListener('resize', resize);
        initMIDI();

        setInterval(cleanupCCs, 1000);
        requestAnimationFrame(loop);
    }

    function shuffleColors(arr) {
        arr.length = 0;
        // Generate 16 random vibrant colors
        for(let i=0; i<16; i++) {
            const h = Math.floor(Math.random() * 360);
            const s = 70 + Math.random() * 30;
            const l = 50 + Math.random() * 20;
            arr.push(`hsl(${h}, ${s}%, ${l}%)`);
        }
    }

    function setupChannelMatrix() {
        for(let i=0; i<16; i++) {
            const d = document.createElement('div');
            d.className = 'ch-led';
            d.textContent = i+1;
            chContainer.appendChild(d);
            chIndicators.push(d);
        }
    }

    function setupChannelFilters(containerId, maskArray) {
        const cont = document.getElementById(containerId);
        cont.innerHTML = '';
        for(let i=0; i<16; i++) {
            const wrap = document.createElement('div');
            wrap.style.display = 'flex'; wrap.style.alignItems='center'; wrap.style.gap='2px';
            const cb = document.createElement('input');
            cb.type = 'checkbox'; cb.checked = true;
            cb.id = `${containerId}-mask-${i}`;
            cb.addEventListener('change', e => maskArray[i] = e.target.checked);
            const lbl = document.createElement('span');
            lbl.innerText = (i+1); lbl.style.fontSize='10px'; lbl.style.color='#666';
            wrap.appendChild(cb); wrap.appendChild(lbl);
            cont.appendChild(wrap);
        }
    }

    function applyTheme(key) {
        currentTheme = key;
        const t = THEMES[key];
        const r = document.documentElement.style;
        r.setProperty('--bg-color', t.bg);
        r.setProperty('--panel-bg', t.panel);
        r.setProperty('--text-color', t.text);
        r.setProperty('--accent-color', t.accent);
        r.setProperty('--data-color', t.data);
        r.setProperty('--grid-beat', t.grid);
        r.setProperty('--grid-bar', t.bar);
        document.getElementById('app-title').innerText = `MK XX // ${key.toUpperCase()}`;
    }

    function cleanupCCs() {
        if (ccTimeout === 0) return;
        const now = performance.now();
        ccMonitors.forEach((mon, id) => {
            if (mon.pinned) return; // Ignore pinned
            if (now - mon.lastUpdate > ccTimeout) {
                mon.element.remove();
                ccMonitors.delete(id);
                bigCCs.delete(id);
            }
        });
        if (ccMonitors.size === 0 && document.getElementById('cc-container').children.length === 0) {
             document.getElementById('cc-container').innerHTML = '<div style="text-align:center; color:var(--text-color); opacity:0.5; font-size:10px; padding-top:20px;">NO SIGNAL</div>';
        }
    }

    function setupEventListeners() {
        const safeListen = (id, evt, fn) => {
            const el = document.getElementById(id);
            if(el) el.addEventListener(evt, fn);
        };

        safeListen('zoom-slider', 'input', e => zoomLevel = parseFloat(e.target.value));
        safeListen('pan-slider', 'input', e => panPercent = parseFloat(e.target.value));

        safeListen('btn-settings', 'click', e => {
            const p = document.getElementById('settings-panel');
            if(p) p.classList.toggle('open');
            e.target.classList.toggle('active');
        });

        safeListen('btn-manual-init', 'click', initMIDI);

        safeListen('btn-toggle-cc', 'click', e => {
            const chk = document.getElementById('chk-cc-panel');
            chk.checked = !chk.checked;
            chk.dispatchEvent(new Event('change'));
            e.target.classList.toggle('active');
        });

        safeListen('btn-toggle-pgm', 'click', e => {
             const chk = document.getElementById('chk-show-pgm');
             chk.checked = !chk.checked;
             chk.dispatchEvent(new Event('change'));
             e.target.classList.toggle('active');
        });

        safeListen('btn-toggle-split', 'click', e => {
            perChannelMode = !perChannelMode;
            e.target.classList.toggle('active', perChannelMode);
            // Redraw/Resize might be needed if structure changes, but loop handles it
        });

        safeListen('btn-shuffle-notes', 'click', () => { shuffleColors(randomPaletteNotes); });
        safeListen('btn-shuffle-cc', 'click', () => { shuffleColors(randomPaletteCC); });

        safeListen('btn-save-cfg', 'click', saveConfig);
        safeListen('btn-load-cfg', 'click', () => document.getElementById('file-input').click());
        safeListen('file-input', 'change', loadConfig);

        safeListen('btn-save-db', 'click', saveCCDatabase);
        safeListen('btn-load-db', 'click', () => document.getElementById('db-input').click());
        safeListen('db-input', 'change', loadCCDatabase);

        const toggle = (id, action) => safeListen(id, 'change', e => action(e.target.checked));
        toggle('chk-bpm', v => {
             const bpmBox = document.getElementById('bpm-box');
             const transDiv = document.getElementById('transport-div');
             const transVal = document.getElementById('transport-val');

             if(v) {
                 bpmBox.style.display = 'flex';
                 transDiv.style.display = 'block';
                 transVal.style.display = 'block';
                 document.getElementById('status-box').style.display = 'flex';
             } else {
                 bpmBox.style.display = 'none';
                 transDiv.style.display = 'none';
                 transVal.style.display = 'none';
                 document.getElementById('status-box').style.display = 'none';
             }
        });
        toggle('chk-matrix', v => document.getElementById('ch-matrix').classList.toggle('visible', v));
        toggle('chk-piano', v => { showPiano = v; document.getElementById('piano-roll-header').classList.toggle('visible', v); resize(); });
        toggle('chk-grid', v => showGrid = v);
        toggle('chk-bar', v => showBarLines = v);
        toggle('chk-labels', v => {
            showLabels = v;
            const btn = document.getElementById('btn-labels');
            if(btn) if(v) btn.classList.add('active'); else btn.classList.remove('active');
        });
        toggle('chk-clines', v => showCLines = v);
        toggle('chk-cc-panel', v => {
            document.getElementById('sidebar').classList.toggle('visible', v);
            const btn = document.getElementById('btn-toggle-cc');
            if(v) btn.classList.add('active'); else btn.classList.remove('active');
            resize();
        });

        safeListen('sel-sidebar-pos', 'change', e => {
            const ws = document.getElementById('main-workspace');
            if (e.target.value === 'bottom') ws.classList.add('sidebar-bottom');
            else ws.classList.remove('sidebar-bottom');
            resize();
        });

        safeListen('sel-direction', 'change', e => {
            direction = e.target.value;
            const ws = document.getElementById('main-workspace');
            ws.className = 'workspace';
            ws.classList.add(`dir-${direction}`);
            if (document.getElementById('sel-sidebar-pos').value === 'bottom') ws.classList.add('sidebar-bottom');
            fallingObjects.length = 0;
            resize();
        });

        safeListen('chk-glow', 'change', e => { if (e.target.checked) glowEnabled = true; else glowEnabled = false; });
        safeListen('chk-cc-glow', 'change', e => ccGlow = e.target.checked);

        safeListen('glow-slider', 'input', e => { if (document.getElementById('chk-glow').checked) glowAmount = parseInt(e.target.value); });
        safeListen('cc-opac-slider', 'input', e => ccOpacity = parseFloat(e.target.value));
        safeListen('persist-slider', 'input', e => persistence = parseFloat(e.target.value));
        safeListen('thick-slider', 'input', e => noteThickness = parseInt(e.target.value));

        // CRT Slider
        safeListen('crt-slider', 'input', e => {
             const val = parseFloat(e.target.value);
             const el = document.getElementById('crt-overlay');
             el.style.opacity = val;
             el.style.display = val > 0 ? 'block' : 'none';
        });

        const sel = (id, action) => safeListen(id, 'change', e => action(e.target.value));
        sel('sel-theme', applyTheme);
        sel('sel-color-mode', v => colorMode = v);
        sel('sel-cc-color-mode', v => ccColorMode = v);
        sel('sel-cc-timeout', v => ccTimeout = parseInt(v));
        sel('sel-font', updateFont);
        sel('sel-shape', v => noteShape = v);
        sel('sel-cc-dir', v => ccScrollDir = v);

        safeListen('speed-slider', 'input', e => noteSpeed = parseInt(e.target.value));
        safeListen('sig-num', 'input', e => { sigNum = parseInt(e.target.value) || 4; updateTimeSig(); });
        safeListen('sig-den', 'input', e => { sigDen = parseInt(e.target.value) || 4; updateTimeSig(); });
        safeListen('grid-thick', 'input', e => barThickness = parseInt(e.target.value));

        safeListen('font-size-slider', 'input', e => {
            fontScale = parseInt(e.target.value);
            document.documentElement.style.setProperty('--font-size-base', fontScale + 'px');
            // Update Channel Filter Fonts (UI Size)
            document.querySelectorAll('.ch-filter-grid span').forEach(el => el.style.fontSize = fontScale + 'px');
        });
        safeListen('cc-size-slider', 'input', e => {
            fontSizeCC = parseInt(e.target.value);
            document.querySelectorAll('.cc-val-big').forEach(el => el.style.fontSize = fontSizeCC + 'px');
        });
        safeListen('btn-sync-fonts', 'click', () => {
             fontSizeCC = fontScale;
             document.getElementById('cc-size-slider').value = fontSizeCC;
             document.querySelectorAll('.cc-val-big').forEach(el => el.style.fontSize = fontSizeCC + 'px');
        });

        safeListen('chk-trails-grid', 'change', e => trailsOnGrid = e.target.checked);

        // New Features Listeners
        safeListen('chk-show-pgm', 'change', e => {
             showPGM = e.target.checked;
             const btn = document.getElementById('btn-toggle-pgm');
             if(btn) if(e.target.checked) btn.classList.add('active'); else btn.classList.remove('active');
        });
        safeListen('chk-fresh-pgm', 'change', e => freshPGM = e.target.checked);
        safeListen('chk-fresh-labels', 'change', e => freshLabels = e.target.checked);
        safeListen('lbl-size-slider', 'input', e => {
            labelSize = parseInt(e.target.value);
        });
        safeListen('chk-lbl-per-bar', 'change', e => labelPerBar = e.target.checked);
        safeListen('sel-lbl-col', 'change', e => labelColorMode = e.target.value);
        safeListen('ovl-smooth-slider', 'input', e => overlaySmooth = parseInt(e.target.value));
        safeListen('ovl-thick-slider', 'input', e => overlayThick = parseInt(e.target.value));
        safeListen('chk-ovl-trail', 'change', e => overlayTrails = e.target.checked);

        safeListen('cc-scale-slider', 'input', e => {
            const w = parseInt(e.target.value);
            document.documentElement.style.setProperty('--cc-graph-width', w + 'px');
            document.querySelectorAll('.cc-widget canvas').forEach(c => {
                c.width = w;
                const mon = ccMonitors.get(c.parentElement.parentElement.dataset.id);
                if(mon) mon.w = w;
            });
        });

        // --- MK21 NEW LISTENERS ---
        safeListen('big-cc-scale-slider', 'input', e => ccScale = parseFloat(e.target.value));
        safeListen('btn-cc-clamp', 'click', e => {
            ccClamp = !ccClamp;
            e.target.classList.toggle('active', ccClamp);
        });
        safeListen('btn-cc-grid-toggle', 'click', e => {
             const chk = document.getElementById('chk-cc-grid');
             chk.checked = !chk.checked;
             e.target.classList.toggle('active', chk.checked);
        });
        safeListen('cc-grid-density-slider', 'input', e => ccGridDensity = parseInt(e.target.value));
        safeListen('cc-smooth-slider', 'input', e => ccSmoothWindow = parseInt(e.target.value));

        safeListen('chk-vel-opacity', 'change', e => {
            // handled in loop, just state
        });
        safeListen('vel-opac-base-slider', 'input', e => velOpacityBase = parseInt(e.target.value) / 100);

        const handle = document.getElementById('drag-handle');
        const sidebar = document.getElementById('sidebar');
        if(handle && sidebar) {
            let isResizing = false;
            handle.addEventListener('mousedown', () => { isResizing = true; document.body.style.cursor = 'col-resize'; });
            window.addEventListener('mousemove', e => {
                if(!isResizing) return;
                if (document.getElementById('main-workspace').classList.contains('sidebar-bottom')) {
                    sidebar.style.height = (window.innerHeight - e.clientY - 50) + 'px';
                } else {
                    sidebar.style.width = (window.innerWidth - e.clientX) + 'px';
                }
                resize();
            });
            window.addEventListener('mouseup', () => { isResizing = false; document.body.style.cursor = 'default'; });
        }

        // --- MOUSE PAN/ZOOM ---
        const vCont = document.getElementById('visualizer-container');
        let isDraggingMain = false;
        let lastX = 0, lastY = 0;

        vCont.addEventListener('mousedown', e => {
            if(e.button === 0) { // Left Click
                isDraggingMain = true;
                lastX = e.clientX;
                lastY = e.clientY;
                vCont.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', e => {
            if(isDraggingMain) {
                const dx = e.clientX - lastX;
                // const dy = e.clientY - lastY; // Unused for now
                lastX = e.clientX;
                lastY = e.clientY;

                // Adjust PAN
                const sens = 0.2;
                panPercent = Math.max(0, Math.min(100, panPercent - (dx * sens)));
                document.getElementById('pan-slider').value = panPercent;
            }
        });

        window.addEventListener('mouseup', () => {
            isDraggingMain = false;
            vCont.style.cursor = 'default';
        });

        vCont.addEventListener('wheel', e => {
            e.preventDefault();
            const sign = Math.sign(e.deltaY);

            if(e.ctrlKey) {
                // Zoom
                zoomLevel = Math.max(1, Math.min(8, zoomLevel - (sign * 0.1)));
                document.getElementById('zoom-slider').value = zoomLevel;
            } else {
                // Pan (Keys/Octaves)
                // In all modes, Pan controls the key range view.
                // Standard sensitivity
                panPercent = Math.max(0, Math.min(100, panPercent + (sign * 2)));
                document.getElementById('pan-slider').value = panPercent;
            }
        }, {passive: false});

        // --- DRAG & DROP CC ---
        vCont.addEventListener('dragover', e => e.preventDefault());
        vCont.addEventListener('drop', e => {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            if(id && ccMonitors.has(id)) {
                 if(!bigCCs.has(id)) toggleBigCC(id);
                 else {
                     // If already present, maybe focus it or just ignore.
                     // The requirement is to trigger the controls too.
                     // But toggleBigCC toggles it OFF if present.
                     // So we should check.
                     // Actually, if it's already there, do nothing? Or bring to front?
                     // Let's just ensure it's ON and controls are visible.
                     if(!bigCCs.has(id)) toggleBigCC(id);
                     else {
                         // Ensure controls are visible
                         const controls = document.getElementById('big-cc-controls');
                         if (controls) controls.style.display = 'block';
                     }
                 }
            }
        });
    }

    function resetCCFilters() {
        hiddenCCs.clear();
        ccMonitors.forEach((mon, id) => {
            mon.element.classList.remove('hidden');
        });
    }

    function toggleBigCC(id) {
        const btn = document.querySelector(`.cc-widget[data-id="${id}"] .cc-enlarge-btn`);
        if (bigCCs.has(id)) {
            bigCCs.delete(id);
            if(btn) btn.classList.remove('active');
        } else {
            bigCCs.add(id);
            if(btn) btn.classList.add('active');
        }

        const controls = document.getElementById('big-cc-controls');
        if (controls) {
            controls.style.display = bigCCs.size > 0 ? 'block' : 'none';
        }
    }

    function saveCCDatabase() {
        // Export persistentLabels map
        const db = Object.fromEntries(persistentLabels);
        const blob = new Blob([JSON.stringify(db, null, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "cc_database.json";
        a.click();
    }

    function loadCCDatabase(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const db = JSON.parse(e.target.result);
                for (const [id, lbl] of Object.entries(db)) {
                    persistentLabels.set(id, lbl);
                    // Update existing widgets if any
                    const mon = ccMonitors.get(id);
                    if(mon) {
                        mon.label = lbl;
                        mon.element.querySelector('.cc-name').innerText = lbl;
                        mon.element.querySelector('.cc-bg-label').innerText = lbl;
                    }
                }
                alert("CC Database Loaded");
            } catch(err) { console.error(err); alert("Invalid DB File"); }
        };
        reader.readAsText(file);
    }

    function saveConfig() {
        // Capture CC Labels
        const ccLabels = {};
        ccMonitors.forEach((mon, id) => {
            if(mon.label) ccLabels[id] = mon.label;
        });

        const cfg = {
            theme: currentTheme,
            noteSpeed, zoomLevel, panPercent, colorMode, ccTimeout,
            showLabels, showGrid, showBarLines, showPiano, showCLines, glowEnabled, glowAmount,
            direction, persistence, noteThickness, noteShape,
            sigNum, sigDen, barThickness, fontScale, fontSizeCC,
            ccScrollDir, channelMaskNotes, channelMaskCC, ccLabels,
            crtOpacity: document.getElementById('crt-slider').value,
            trailsOnGrid,
            showPGM, freshPGM, freshLabels, labelSize, labelColorMode,
            overlaySmooth, overlayThick, overlayTrails, ccColorMode, ccGlow, ccOpacity,
            sidebarPos: document.getElementById('sel-sidebar-pos').value
        };
        const blob = new Blob([JSON.stringify(cfg)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "cathedral_v20_config.json";
        a.click();
    }

    function loadConfig(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if(data.theme) { currentTheme=data.theme; document.getElementById('sel-theme').value=data.theme; applyTheme(data.theme); }
                if(data.noteSpeed) { noteSpeed=data.noteSpeed; document.getElementById('speed-slider').value=data.noteSpeed; }
                if(data.zoomLevel) { zoomLevel=data.zoomLevel; document.getElementById('zoom-slider').value=data.zoomLevel; }
                if(data.panPercent) { panPercent=data.panPercent; document.getElementById('pan-slider').value=data.panPercent; }
                if(data.colorMode) { colorMode=data.colorMode; document.getElementById('sel-color-mode').value=data.colorMode; }
                if(data.ccColorMode) { ccColorMode=data.ccColorMode; document.getElementById('sel-cc-color-mode').value=data.ccColorMode; }

                const setChk = (id, val) => { const el=document.getElementById(id); if(el) { el.checked=val; el.dispatchEvent(new Event('change')); }};
                if(data.showLabels!==undefined) setChk('chk-labels', data.showLabels);
                if(data.showGrid!==undefined) setChk('chk-grid', data.showGrid);
                if(data.showBarLines!==undefined) setChk('chk-bar', data.showBarLines);
                if(data.showPiano!==undefined) setChk('chk-piano', data.showPiano);
                if(data.showCLines!==undefined) setChk('chk-clines', data.showCLines);
                if(data.glowEnabled!==undefined) setChk('chk-glow', data.glowEnabled);

                if(data.glowAmount) { glowAmount=data.glowAmount; document.getElementById('glow-slider').value=data.glowAmount; }
                if(data.persistence) { persistence=data.persistence; document.getElementById('persist-slider').value=data.persistence; }
                if(data.noteThickness) { noteThickness=data.noteThickness; document.getElementById('thick-slider').value=data.noteThickness; }
                if(data.noteShape) { noteShape=data.noteShape; document.getElementById('sel-shape').value=data.noteShape; }

                if(data.sigNum) document.getElementById('sig-num').value = data.sigNum;
                if(data.sigDen) document.getElementById('sig-den').value = data.sigDen;
                if(data.barThickness) document.getElementById('grid-thick').value = data.barThickness;
                if(data.fontScale) { fontScale=data.fontScale; document.getElementById('font-size-slider').value=data.fontScale; document.documentElement.style.setProperty('--font-size-base', fontScale+'px'); }
                if(data.fontSizeCC) {
                    fontSizeCC=data.fontSizeCC; document.getElementById('cc-size-slider').value=data.fontSizeCC;
                    document.querySelectorAll('.cc-val-big').forEach(el => el.style.fontSize = fontSizeCC + 'px');
                }

                if(data.crtOpacity) {
                    const el = document.getElementById('crt-slider');
                    el.value = data.crtOpacity;
                    el.dispatchEvent(new Event('input'));
                }

                if(data.channelMaskNotes) {
                    channelMaskNotes = data.channelMaskNotes;
                    channelMaskNotes.forEach((v, i) => {
                        const cb = document.getElementById(`ch-filter-container-notes-mask-${i}`);
                        if(cb) cb.checked = v;
                    });
                }

                if(data.channelMaskCC) {
                    channelMaskCC = data.channelMaskCC;
                    channelMaskCC.forEach((v, i) => {
                        const cb = document.getElementById(`ch-filter-container-cc-mask-${i}`);
                        if(cb) cb.checked = v;
                    });
                }

                if(data.direction) { direction=data.direction; document.getElementById('sel-direction').value=data.direction; document.getElementById('sel-direction').dispatchEvent(new Event('change')); }
                if(data.sidebarPos) { document.getElementById('sel-sidebar-pos').value=data.sidebarPos; document.getElementById('sel-sidebar-pos').dispatchEvent(new Event('change')); }
                if(data.ccScrollDir) { ccScrollDir=data.ccScrollDir; document.getElementById('sel-cc-dir').value=data.ccScrollDir; }

                if(data.trailsOnGrid !== undefined) { setChk('chk-trails-grid', data.trailsOnGrid); }

                if(data.showPGM !== undefined) setChk('chk-show-pgm', data.showPGM);
                if(data.freshPGM !== undefined) setChk('chk-fresh-pgm', data.freshPGM);
                if(data.freshLabels !== undefined) setChk('chk-fresh-labels', data.freshLabels);
                if(data.labelSize !== undefined) { labelSize=data.labelSize; document.getElementById('lbl-size-slider').value=data.labelSize; }
                if(data.labelColorMode !== undefined) { labelColorMode=data.labelColorMode; document.getElementById('sel-lbl-col').value=data.labelColorMode; }
                if(data.overlaySmooth !== undefined) { overlaySmooth=data.overlaySmooth; document.getElementById('ovl-smooth-slider').value=data.overlaySmooth; }
                if(data.overlayThick !== undefined) { overlayThick=data.overlayThick; document.getElementById('ovl-thick-slider').value=data.overlayThick; }
                if(data.overlayTrails !== undefined) setChk('chk-ovl-trail', data.overlayTrails);

                if(data.ccOpacity !== undefined) { ccOpacity=data.ccOpacity; document.getElementById('cc-opac-slider').value=data.ccOpacity; }
                if(data.ccGlow !== undefined) setChk('chk-cc-glow', data.ccGlow);

                if(data.ccLabels) {
                    for (const [id, lbl] of Object.entries(data.ccLabels)) {
                        const mon = ccMonitors.get(id);
                        if(mon) {
                            mon.label = lbl;
                            mon.element.querySelector('.cc-name').innerText = lbl;
                            mon.element.querySelector('.cc-bg-label').innerText = lbl;
                        }
                    }
                }

                updateTimeSig();
            } catch(err) { console.error(err); alert("Invalid Config File"); }
        };
        reader.readAsText(file);
    }

    function updateTimeSig() {
        ticksPerBar = Math.round((4 / sigDen) * sigNum * CONFIG.PPQN);
        barTickCounter = 0;
    }

    function updateFont(val) {
        // Set dropdown
        const dd = document.getElementById('sel-font');
        if(dd.value !== val) dd.value = val;

        const r = document.documentElement.style;
        let stack = "sans-serif";

        if(val==='tech') stack = "'Rajdhani', sans-serif";
        else if(val==='hacker') stack = "'VT323', monospace";
        else if(val==='gory') stack = "'Nosifer', cursive";
        else if(val==='elegant') stack = "'Playfair Display', serif";
        else if(val==='scifi') stack = "'Orbitron', sans-serif";

        currentFontStack = stack;
        r.setProperty('--font-stack', stack);
    }

    function resize() {
        const vCont = document.getElementById('visualizer-container');
        mainCanvas.width = vCont.offsetWidth;
        mainCanvas.height = vCont.offsetHeight;
        overlayCanvas.width = vCont.offsetWidth;
        overlayCanvas.height = vCont.offsetHeight;

        if (direction === 'down' || direction === 'up') {
            pianoCanvas.width = vCont.offsetWidth;
            pianoCanvas.height = 30;
        } else {
            pianoCanvas.width = 40;
            pianoCanvas.height = vCont.offsetHeight;
        }
    }

    function getNoteColor(note, ch) {
        if (currentTheme === 'chernobyl') return '#00ffff';
        if (colorMode === 'channel') return THEMES[currentTheme].ch[ch];
        if (colorMode === 'octave') {
            const octave = Math.floor(note / 12);
            const PAL = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#FFFFFF', '#FF00FF', '#00FFFF'];
            return PAL[octave % PAL.length];
        }
        if (colorMode === 'root') return THEMES[currentTheme].ch[note % 12];
        if (colorMode === 'random') return randomPaletteNotes[ch];
        return '#fff';
    }

    function getCCColor(ch, cc) {
        if(ccColorMode === 'match') return THEMES[currentTheme].ch[ch];
        if(ccColorMode === 'white') return '#ffffff';
        if(ccColorMode === 'random') return randomPaletteCC[ch];

        // Check if it's a theme name
        if(THEMES[ccColorMode]) {
            return THEMES[ccColorMode].ch[ch];
        }
        return THEMES[currentTheme].ch[ch];
    }

    async function initMIDI() {
        const sel = document.getElementById('midi-input');
        if (!navigator.requestMIDIAccess) {
            sel.innerHTML = '<option>NO BROWSER SUPPORT</option>';
            return;
        }
        try {
            midiAccess = await navigator.requestMIDIAccess();
            midiAccess.onstatechange = refreshInputs;
            refreshInputs();
        } catch(e){
            console.error(e);
            sel.innerHTML = '<option>ACCESS DENIED (RETRY)</option>';
        }
    }

    function refreshInputs() {
        const sel = document.getElementById('midi-input');
        sel.innerHTML = '';
        const inputs = Array.from(midiAccess.inputs.values());
        if(inputs.length===0) sel.innerHTML = '<option>NO DEVICES FOUND</option>';
        else {
            const d = document.createElement('option'); d.text = "-- SELECT DEVICE --"; sel.appendChild(d);
            inputs.forEach(i => {
                const o = document.createElement('option'); o.value = i.id; o.text = i.name; sel.appendChild(o);
            });
        }
        if(selectedInputId) sel.value = selectedInputId;
    }

    document.getElementById('midi-input').addEventListener('change', e => {
        if(selectedInputId && midiAccess.inputs.has(selectedInputId))
            midiAccess.inputs.get(selectedInputId).onmidimessage = null;
        selectedInputId = e.target.value;
        const input = midiAccess.inputs.get(selectedInputId);
        if(input) input.onmidimessage = handleMsg;
    });

    function handleMsg(msg) {
        const [status, d1, d2] = msg.data;
        const cmd = status >> 4;
        const ch = status & 0xf;

        if (status === 0xF8) { handleClock(); return; }
        if (status === 0xFA) { setTransport('PLAY', '#00ff41'); return; }
        if (status === 0xFB) { setTransport('CONT', '#ffff00'); return; }
        if (status === 0xFC) { setTransport('STOP', '#ff0055'); resetClock(); return; }

        if (status >= 0xF8) return;

        const now = performance.now();

        // Channel filtering logic
        // PGM Change (0xC0)
        if (cmd === 12) {
            // Program Change has only 1 data byte usually (d1)
            // It applies to a channel, so filter by Note Mask (closest fit for "events")?
            // Or CC Mask? Usually PGM is control. Let's use CC mask.
            if(channelMaskCC[ch] === false) return;

            fallingObjects.push({
                 type: 'pgm',
                 val: d1,
                 ch: ch,
                 pos: 0,
                 len: 2, // thin line
                 timeDropped: now
            });
            flashCh(ch, '#FFF', true);
            return;
        }

        if (cmd === 9 && d2 > 0) {
            if (channelMaskNotes[ch] === false) return;
            const col = getNoteColor(d1, ch);

            // Label Logic
            let showLabel = true;
            if (labelPerBar) {
                if (barLabels.has(d1)) showLabel = false;
                else barLabels.add(d1);
            }

            activeNotes.set(`${ch}-${d1}`, {
                note: d1, ch, vel: d2, start: now,
                color: col,
                showLabel: showLabel
            });
            flashCh(ch, col);
        }
        else if (cmd === 8 || (cmd === 9 && d2 === 0)) {
            const id = `${ch}-${d1}`;
            if (activeNotes.has(id)) {
                const n = activeNotes.get(id);
                const duration = now - n.start;
                const len = noteSpeed * (duration / 16.66);
                fallingObjects.push({
                    type: 'note', note: n.note,
                    pos: 0, len: len,
                    color: n.color,
                    vel: n.vel,
                    ch: n.ch, // Store Channel
                    showLabel: n.showLabel,
                    timeDropped: now
                });
                activeNotes.delete(id);
            }
        }
        else if (cmd === 11) {
            if (channelMaskCC[ch] === false) return;
            handleCC(ch, d1, d2);
            flashCh(ch, null, true);
        }
    }

    function setTransport(txt, color) {
        const el = document.getElementById('transport-val');
        el.innerText = txt;
        el.style.color = color;
    }

    function resetClock() {
        clockTicks = 0; barTickCounter = 0;
    }

    function flashCh(ch, color, isCC=false) {
        const el = chIndicators[ch];
        if(!el) return;

        if(isCC) {
            el.style.backgroundColor = 'var(--data-color)';
            el.style.color = '#000';
        } else {
            el.style.backgroundColor = color;
            el.style.color = '#000';
            el.style.boxShadow = `0 0 8px ${color}`;
        }
        setTimeout(() => {
            el.style.backgroundColor = '';
            el.style.color = '';
            el.style.boxShadow = '';
        }, 100);
    }

    function handleClock() {
        const now = performance.now();
        lastActiveClock = now;

        if (clockTicks % 24 === 0) {
            const dot = document.getElementById('clock-dot');
            dot.classList.add('beat');
            setTimeout(() => dot.classList.remove('beat'), 100);
        }

        if (lastClockTime > 0) {
            const delta = now - lastClockTime;
            if (delta > 2 && delta < 200) {
                tickHistory.push(delta);
                if(tickHistory.length > 192) tickHistory.shift();

                if(clockTicks % 24 === 0) {
                    const avgDelta = tickHistory.reduce((a,b)=>a+b,0) / tickHistory.length;
                    const bpm = 60000 / (avgDelta * 24);
                    document.getElementById('bpm-val').innerText = bpm.toFixed(1);
                }
            }
        }
        lastClockTime = now;

        if (showBarLines && barTickCounter >= ticksPerBar) {
            fallingObjects.push({ type: 'grid', pos: 0, isBar: true, timeDropped: now });
            barTickCounter = 0;
            barLabels.clear(); // Reset labels per bar logic
        }

        const beatInterval = CONFIG.PPQN;
        if (showGrid && clockTicks % beatInterval === 0) {
            if (barTickCounter !== 0) {
                fallingObjects.push({ type: 'grid', pos: 0, isBar: false, timeDropped: now });
            }
        }

        clockTicks++;
        barTickCounter++;
    }

    function handleCC(ch, cc, val) {
        const id = `${ch + 1}-${cc}`;
        if(hiddenCCs.has(id)) return;

        let mon = ccMonitors.get(id);
        const cont = document.getElementById('cc-container');
        const chColor = THEMES[currentTheme].ch[ch];
        const valFont = "'Share Tech Mono', monospace";

        if (!mon) {
            if(ccMonitors.size === 0 && (cont.children.length === 0 || cont.children[0]?.innerText.includes("NO SIGNAL"))) cont.innerHTML = '';

            const el = document.createElement('div');
            el.className = 'cc-widget';
            el.draggable = true;
            el.dataset.id = id;
            el.dataset.ch = ch;
            el.dataset.cc = cc;

            el.innerHTML = `
                <div class="cc-meta">
                    <div style="display:flex; justify-content:space-between; width:100%;">
                        <div style="display:flex; flex-direction:column; gap:1px; font-size:10px; font-weight:bold;">
                            <div><span style="color:#666">CH</span> <span style="color:${chColor}">${ch+1}</span></div>
                            <div><span style="color:#666">CC</span> <span style="color:${chColor}">${cc}</span></div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:2px; align-items:center;">
                            <div class="cc-pin-btn" title="Pin Graph"></div>
                            <button class="cc-enlarge-btn icon-btn" onclick="toggleBigCC('${id}')" style="padding: 0px 4px; font-size: 10px; height:14px; line-height:12px;">+</button>
                        </div>
                    </div>
                    <span class="cc-name" style="font-size:10px; opacity:0.7; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width:68px;"></span>
                </div>
                <div class="cc-val-big" style="font-family:${valFont}; font-size:${fontSizeCC}px; color:var(--data-color);">${val}</div>
                <div class="cc-graph-container">
                    <div class="cc-bg-label"></div>
                    <canvas></canvas>
                </div>
            `;

            const pinBtn = el.querySelector('.cc-pin-btn');
            pinBtn.style.pointerEvents = "auto"; // Ensure clickability
            el.querySelector('.cc-meta').style.pointerEvents = "auto"; // Enable meta clicks if needed, but keep name safe

            pinBtn.onclick = (e) => {
                e.stopPropagation();
                mon.pinned = !mon.pinned;
                pinBtn.classList.toggle('active', mon.pinned);
            };

            // Rename only on graph click
            el.querySelector('.cc-graph-container').onclick = () => {
                const name = prompt("Rename CC Graph:", mon.label || `CH${ch+1} CC${cc}`);
                if (name) {
                    mon.label = name.toUpperCase();
                    persistentLabels.set(id, mon.label);
                    el.querySelector('.cc-name').innerText = mon.label;
                    el.querySelector('.cc-bg-label').innerText = mon.label;
                }
            };

            el.oncontextmenu = (e) => {
                e.preventDefault();
                hiddenCCs.add(id);
                el.classList.add('hidden');
            };

            el.ondragstart = (e) => {
                e.dataTransfer.setData('text/plain', id);
            };

            const children = Array.from(cont.children);
            let inserted = false;
            for(let child of children) {
                const cCh = parseInt(child.dataset.ch);
                const cCc = parseInt(child.dataset.cc);
                if (!isNaN(cCh) && (ch < cCh || (ch === cCh && cc < cCc))) {
                    cont.insertBefore(el, child);
                    inserted = true;
                    break;
                }
            }
            if(!inserted) cont.appendChild(el);

            const cvs = el.querySelector('canvas');
            // get ccScale from CSS var or element width, but wait, ccScale is now multiplier for big.
            // Small scale comes from slider "CC SCALE" -> var --cc-graph-width.
            const smallW = parseInt(document.getElementById('cc-scale-slider').value);
            cvs.width = smallW;
            cvs.height = 30;

            // Restore persistent label if exists
            const savedLabel = persistentLabels.get(id) || '';
            if(savedLabel) {
                el.querySelector('.cc-name').innerText = savedLabel;
                el.querySelector('.cc-bg-label').innerText = savedLabel;
            }

            mon = {
                ch, cc, val,
                history: [],
                element: el,
                valEl: el.querySelector('.cc-val-big'),
                ctx: cvs.getContext('2d'),
                w: smallW, h: 30,
                color: getCCColor(ch, cc),
                lastUpdate: performance.now(),
                label: savedLabel,
                pinned: false
            };

            ccMonitors.set(id, mon);
            mon.history.push({t: performance.now(), v: val});

            const ro = new ResizeObserver(() => {
                const rect = el.querySelector('.cc-graph-container').getBoundingClientRect();
                if(rect.width > 0) {
                    cvs.width = rect.width; cvs.height = rect.height;
                    mon.w = cvs.width; mon.h = cvs.height;
                }
            });
            ro.observe(el.querySelector('.cc-graph-container'));
        } else {
            mon.val = val;
            mon.lastUpdate = performance.now();
            mon.valEl.innerText = val;
            mon.color = THEMES[currentTheme].ch[ch];

            // Ensure label color update if theme changed
            const rows = mon.element.querySelectorAll('.cc-meta span');
            if(rows.length >= 4) {
                rows[1].style.color = mon.color; // CH Number
                rows[3].style.color = mon.color; // CC Number
            }

            mon.history.push({t: performance.now(), v: val});

            const timeWindow = 60000; // Increased history
            while(mon.history.length > 0 && mon.history[0].t < performance.now() - timeWindow) {
                mon.history.shift();
            }
        }
    }

    function drawCCGraphs(now) {
        ccMonitors.forEach(mon => {
            const ctx = mon.ctx;
            const w = mon.w;
            const h = mon.h;

            // Dynamic Window Size based on Note Speed to match visualizer flow
            // Time (ms) = Pixels * 16.66 / Speed
            // We use a bit of buffer (1.2x) to ensure lines go off edges
            let windowSize = 5000;
            if (noteSpeed > 0) {
                windowSize = (w * 16.66 / noteSpeed) * 1.2;
                if(windowSize < 1000) windowSize = 1000;
            }

            // Update Color Dynamically
            const col = getCCColor(mon.ch, mon.cc);
            mon.color = col; // Sync for big overlay usage

            // Update Small Widget Colors
            const meta = mon.element.querySelectorAll('.cc-meta span');
            if(meta.length >=4) { meta[1].style.color = col; meta[3].style.color = col; }

            ctx.clearRect(0,0,w,h);
            ctx.strokeStyle = col;
            ctx.lineWidth = 2;
            ctx.beginPath();

            const points = [...mon.history];
            points.push({t: now, v: mon.val});

            if (points.length === 0) return;

            const startTime = now - windowSize;
            let firstPoint = true;

            for(let i=0; i<points.length; i++) {
                const p = points[i];
                let x;
                if (ccScrollDir === 'left') {
                    x = ((p.t - startTime) / windowSize) * w;
                } else {
                    x = ((now - p.t) / windowSize) * w;
                }
                const y = h - (p.v / 127) * h;

                if(firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    const prevP = points[i-1];
                    let prevX;
                    if (ccScrollDir === 'left') prevX = ((prevP.t - startTime) / windowSize) * w;
                    else prevX = ((now - prevP.t) / windowSize) * w;
                    const prevY = h - (prevP.v / 127) * h;

                    ctx.lineTo(x, prevY);
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        });
    }

    function renameCC(id) {
        // Replaced by inline onclick
    }

    window.clearCC = function() {
        // Only clear history, do not destroy widgets
        ccMonitors.forEach(mon => {
            mon.history = [];
        });
    }

    function drawNoteShape(ctx, x, y, w, h, type) {
        if (type === 'bar') {
            ctx.fillRect(x, y, w, h);
        } else if (type === 'bubble') {
            ctx.beginPath();
            const r = Math.min(w, h)/2;
            if(r < 1) { ctx.fillRect(x,y,w,h); return; }
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();
        } else if (type === 'tear') {
            ctx.beginPath();
            // Direction dependent teardrop?
            if (direction === 'down' || direction === 'right') {
                 ctx.moveTo(x, y);
                 ctx.lineTo(x+w, y);
                 ctx.lineTo(x+w/2, y+h);
                 ctx.fill();
            } else {
                 ctx.moveTo(x+w/2, y);
                 ctx.lineTo(x+w, y+h);
                 ctx.lineTo(x, y+h);
                 ctx.fill();
            }
        } else if (type === 'hex') {
             ctx.beginPath();
             const p = 0.2;
             if (direction === 'down' || direction === 'up') {
                 ctx.moveTo(x, y + h*p);
                 ctx.lineTo(x + w/2, y);
                 ctx.lineTo(x + w, y + h*p);
                 ctx.lineTo(x + w, y + h*(1-p));
                 ctx.lineTo(x + w/2, y + h);
                 ctx.lineTo(x, y + h*(1-p));
             } else {
                 ctx.moveTo(x + w*p, y);
                 ctx.lineTo(x + w*(1-p), y);
                 ctx.lineTo(x + w, y + h/2);
                 ctx.lineTo(x + w*(1-p), y + h);
                 ctx.lineTo(x + w*p, y + h);
                 ctx.lineTo(x, y + h/2);
             }
             ctx.fill();
        } else {
             ctx.fillRect(x, y, w, h);
        }
    }

    let lastFrameTime = performance.now();
    function loop() {
        requestAnimationFrame(loop);

        const now = performance.now();
        const dt = now - lastFrameTime;
        lastFrameTime = now;

        const moveDist = noteSpeed * (dt / 16.66);

        if (now - lastActiveClock > 2000 && lastActiveClock !== 0) {
            document.getElementById('bpm-val').innerText = "NO CLOCK";
            lastActiveClock = 0;
        }

        // PHYSICS UPDATE
        for(let i=fallingObjects.length-1; i>=0; i--) {
            const o = fallingObjects[i];
            o.pos += moveDist;
            // Remove if off screen? depends on direction and max dimension
            // Safe max dimension check
            const maxDim = Math.max(mainCanvas.width, mainCanvas.height);
            if(o.pos > maxDim + o.len + 100) { fallingObjects.splice(i,1); }
        }

        // CC Render (Small Widgets)
        drawCCGraphs(now);

        // CLEAR CANVAS
        mainCtx.save();
        if (persistence > 0) {
            const bg = getComputedStyle(document.body).getPropertyValue('--bg-color');
            mainCtx.globalAlpha = (1 - persistence);
            mainCtx.fillStyle = bg;
            mainCtx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
            mainCtx.globalAlpha = 1.0;
        } else {
            mainCtx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
            const bg = getComputedStyle(document.body).getPropertyValue('--bg-color');
            mainCtx.fillStyle = bg;
            mainCtx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
        }
        mainCtx.restore();
        overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);

        const isVertical = (direction === 'down' || direction === 'up');

        if (perChannelMode) {
            // --- SPLIT MODE ---
            // 1. Identify Active Split Channels
            const activeChs = [];
            for(let i=0; i<16; i++) {
                if(channelMaskSplit[i]) activeChs.push(i);
            }
            if(activeChs.length === 0) activeChs.push(0); // Fallback

            const count = activeChs.length;
            let size, offset;

            // Draw Piano BG for whole strip first? No, per strip.

            activeChs.forEach((ch, idx) => {
                let bounds;
                if(isVertical) {
                    size = mainCanvas.width / count;
                    bounds = {x: idx * size, y: 0, w: size, h: mainCanvas.height};
                } else {
                    size = mainCanvas.height / count;
                    bounds = {x: 0, y: idx * size, w: mainCanvas.width, h: size};
                }

                // Determine Note Range for this Channel
                const range = getChannelRange(ch); // {min, max}

                // Draw Strip Border
                overlayCtx.strokeStyle = '#333';
                overlayCtx.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);

                // Clip & Draw
                mainCtx.save(); overlayCtx.save(); pianoCtx.save();

                const clipPath = new Path2D();
                clipPath.rect(bounds.x, bounds.y, bounds.w, bounds.h);
                mainCtx.clip(clipPath); overlayCtx.clip(clipPath); pianoCtx.clip(clipPath); // Piano ctx isn't used directly here usually, but if we draw piano..

                // Calculate keys based on Range
                // range.min to range.max maps to bounds width/height
                // Need to mock visKeys, keyW logic
                const keyCount = range.max - range.min + 1;
                // Wait, startKey/endKey logic

                let sKey = range.min;
                let eKey = range.max + 1;
                let vKeys = keyCount;

                // Padding
                // If range is single note, add padding
                if (vKeys < 12) {
                    const diff = 12 - vKeys;
                    sKey -= Math.floor(diff/2);
                    eKey += Math.ceil(diff/2);
                    vKeys = 12;
                }
                // Clamp
                // sKey = Math.max(0, sKey); eKey = Math.min(128, eKey);

                let kW;
                if(isVertical) kW = bounds.w / vKeys;
                else kW = bounds.h / vKeys; // keyHeight actually

                if (isVertical) drawVertical(sKey, eKey, vKeys, moveDist, kW, bounds, ch);
                else drawHorizontal(sKey, eKey, vKeys, moveDist, kW, bounds, ch);

                // Draw Big CCs restricted to this channel and bounds
                if (bigCCs.size > 0) drawBigCCsSplit(now, isVertical, bounds, ch);

                mainCtx.restore(); overlayCtx.restore(); pianoCtx.restore();
            });

        } else {
            // --- STANDARD MODE ---
            const visKeys = 128 / zoomLevel;
            const maxStart = 128 - visKeys;
            const startKey = (panPercent / 100) * maxStart;
            const endKey = startKey + visKeys;
            let keyW;

            if (isVertical) {
                keyW = mainCanvas.width / visKeys;
                drawVertical(startKey, endKey, visKeys, moveDist, keyW, {x:0, y:0, w:mainCanvas.width, h:mainCanvas.height}, null);
            } else {
                keyW = mainCanvas.height / visKeys; // Actually keyHeight
                drawHorizontal(startKey, endKey, visKeys, moveDist, keyW, {x:0, y:0, w:mainCanvas.width, h:mainCanvas.height}, null);
            }

            if(bigCCs.size > 0) drawBigCCs(now, isVertical);
        }
    }

    function getChannelRange(ch) {
        let min = 127, max = 0;
        let found = false;

        // Check active notes
        activeNotes.forEach(n => {
            if(n.ch === ch) {
                if(n.note < min) min = n.note;
                if(n.note > max) max = n.note;
                found = true;
            }
        });

        // Check falling objects (trails)
        fallingObjects.forEach(o => {
            if(o.type === 'note' && o.ch === ch) {
                if(o.note < min) min = o.note;
                if(o.note > max) max = o.note;
                found = true;
            }
        });

        if(!found) return {min: 36, max: 84}; // Default range if empty
        return {min: Math.max(0, min-2), max: Math.min(127, max+2)};
    }

    function drawVertical(startKey, endKey, visKeys, moveDist, keyW, bounds = {x:0,y:0,w:mainCanvas.width, h:mainCanvas.height}, filterCh = null) {
        const thickW = keyW * (noteThickness / 100);
        const thickOffset = (keyW - thickW) / 2;

        // PIANO
        if(showPiano) {
            // Fill Background for this strip
            pianoCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--panel-bg');
            pianoCtx.fillRect(bounds.x, 0, bounds.w, pianoCanvas.height);

            for(let i=Math.floor(startKey); i<endKey; i++) {
                const x = bounds.x + Math.floor((i-startKey)*keyW);
                const w = Math.ceil(keyW);
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);
                const noteName = CONFIG.NOTE_NAMES[i%12];

                pianoCtx.fillStyle = isBlack ? '#222' : '#888';
                pianoCtx.fillRect(x, isBlack?0:10, w-1, isBlack?18:20);

                if(noteName === "C") {
                    mainCtx.save();
                    mainCtx.fillStyle = 'rgba(255,255,255,0.5)';
                    mainCtx.font = `bold ${fontScale}px ${currentFontStack}`;
                    const octave = Math.floor(i/12) - 1;
                    const lblY = (direction === 'down') ? 15 : mainCanvas.height - 5;
                    mainCtx.fillText("C"+octave, x + 2, lblY);
                    mainCtx.restore();
                }
            }
        }

        // C-LINES
        if (showCLines) {
            mainCtx.save();
            mainCtx.lineWidth = 1;
            mainCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            mainCtx.font = `bold ${fontScale*1.5}px ${currentFontStack}`;
            mainCtx.fillStyle = 'rgba(255,255,255,0.1)';
            for(let i=Math.floor(startKey); i<endKey; i++) {
                if (i % 12 === 0) {
                     const x = bounds.x + Math.floor((i-startKey)*keyW);
                     mainCtx.beginPath();
                     mainCtx.moveTo(x, bounds.y); mainCtx.lineTo(x, bounds.y + bounds.h);
                     mainCtx.stroke();
                     if(!showPiano) {
                         mainCtx.fillText("C" + (Math.floor(i/12)-1), x + 5, bounds.y + bounds.h - 20);
                     }
                }
            }
            mainCtx.restore();
        }

        // FALLING
        const now = performance.now(); // For Overlay CC

        for(let i=fallingObjects.length-1; i>=0; i--) {
            const o = fallingObjects[i];

            // Only update position once per frame per object?
            // `loop` calls this multiple times if activeChs > 1.
            // But `fallingObjects` logic (pos update) should be in `loop` OUTSIDE the draw functions?
            // Correct. I moved position update to `loop` implicitly?
            // Wait, previous `loop` had `o.pos += moveDist`.
            // My NEW `loop` removed the `fallingObjects` loop!
            // I must restore the physics loop outside of `drawVertical`.

            // Wait, I see I removed the falling objects loop from `loop`.
            // I need to add it back to `loop` OR handle it here but ensure it runs once.
            // Best to handle physics in `loop` globally, then rendering here.

            // I will assume `loop` handles physics (I will fix `loop` next if I missed it).
            // Actually, I can't modify `loop` easily now as I already patched it.
            // I should put physics in here but safeguard? No, that's bad if multiple views.

            // Let's assume for now I will fix `loop` to update positions.
            // Filter by Channel
            if (filterCh !== null) {
                if (o.type === 'note' && o.ch !== filterCh) continue;
                if (o.type === 'pgm' && o.ch !== filterCh) continue;
            }

            if(o.type === 'grid') {
                const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;
                targetCtx.strokeStyle = o.isBar ? getComputedStyle(document.body).getPropertyValue('--grid-bar') : getComputedStyle(document.body).getPropertyValue('--grid-beat');
                targetCtx.lineWidth = o.isBar ? barThickness : 1;
                targetCtx.beginPath();

                if (direction === 'down') {
                    targetCtx.moveTo(bounds.x, o.pos); targetCtx.lineTo(bounds.x + bounds.w, o.pos);
                } else {
                    const y = mainCanvas.height - o.pos;
                    targetCtx.moveTo(bounds.x, y); targetCtx.lineTo(bounds.x + bounds.w, y);
                }
                targetCtx.stroke();
                targetCtx.restore();
            }
            else if(o.type === 'pgm') {
                if(!showPGM) continue;
                const targetCtx = freshPGM ? overlayCtx : mainCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;
                const pgmCol = getNoteColor(o.val, o.val % 16);
                targetCtx.fillStyle = pgmCol;
                targetCtx.globalAlpha = 0.4;

                let py;
                if(direction === 'down') py = o.pos;
                else py = mainCanvas.height - o.pos;

                targetCtx.fillRect(bounds.x, py, bounds.w, 4);
                targetCtx.globalAlpha = 1.0;

                targetCtx.font = `bold ${labelSize}px ${currentFontStack}`;
                targetCtx.fillStyle = pgmCol;
                targetCtx.fillText(`PGM ${o.val}`, bounds.x + 10, py - 5);
                targetCtx.restore();
            }
            else if(o.type === 'note') {
                if(o.note < startKey || o.note >= endKey) continue;
                const x = bounds.x + Math.floor((o.note - startKey)*keyW) + thickOffset;

                mainCtx.save();
                if(document.getElementById('chk-vel-opacity').checked && o.vel !== undefined) {
                    const op = velOpacityBase + (o.vel / 127) * (1 - velOpacityBase);
                    mainCtx.globalAlpha = op;
                }
                if(glowEnabled && glowAmount > 0) {
                    mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : o.color;
                    mainCtx.shadowBlur = glowAmount;
                }
                mainCtx.fillStyle = o.color;

                let ry;
                if (direction === 'down') { ry = o.pos; }
                else { ry = mainCanvas.height - o.pos - o.len; }

                drawNoteShape(mainCtx, x, ry, Math.ceil(thickW), o.len, noteShape);
                mainCtx.restore();

                if(showLabels && keyW > 15) {
                    if (!labelPerBar || o.showLabel !== false) {
                        const targetCtx = freshLabels ? overlayCtx : mainCtx;
                        targetCtx.save(); targetCtx.shadowBlur=0;
                        targetCtx.fillStyle = (labelColorMode === 'match') ? o.color : '#fff';
                        targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                        let ly;
                        if (direction === 'down') ly = o.pos + o.len + 12;
                        else ly = (mainCanvas.height - o.pos - o.len) - 5;

                        targetCtx.fillText(CONFIG.NOTE_NAMES[o.note%12], x+2, ly);
                        targetCtx.restore();
                    }
                }
            }
        }

        // BIG CC OVERLAY (Vertical) - REFACTORED MK21
        if(bigCCs.size > 0) {
            drawBigCCs(now, true);
        }

        // ACTIVE
        activeNotes.forEach(n => {
            if(n.note < startKey || n.note >= endKey) return;
            const x = Math.floor((n.note - startKey)*keyW) + thickOffset;
            const duration = performance.now() - n.start;
            const len = noteSpeed * (duration / 16.66);

            mainCtx.save();

            // Opacity Logic
            if(document.getElementById('chk-vel-opacity').checked) {
                const op = velOpacityBase + (n.vel / 127) * (1 - velOpacityBase);
                mainCtx.globalAlpha = op;
            }

            if(glowEnabled && glowAmount > 0) {
                mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : n.color;
                mainCtx.shadowBlur = glowAmount;
            }
            mainCtx.fillStyle = n.color;

            let ry;
            if (direction === 'down') { ry = 0; }
            else { ry = mainCanvas.height - len; }

            drawNoteShape(mainCtx, x, ry, Math.ceil(thickW), len, noteShape);
            mainCtx.restore();

            if(showLabels && keyW > 15) {
                // Active note label - use baked property
                if(!labelPerBar || n.showLabel !== false) {
                    const targetCtx = freshLabels ? overlayCtx : mainCtx;
                    targetCtx.save(); targetCtx.shadowBlur=0;
                    targetCtx.fillStyle = (labelColorMode === 'match') ? n.color : '#fff';
                    targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                    let ly;
                    if (direction === 'down') ly = len + 12;
                    else ly = (mainCanvas.height - len) - 5;

                    targetCtx.fillText(CONFIG.NOTE_NAMES[n.note%12], x+2, ly);
                    targetCtx.restore();
                }
            }
        });

        // GRID LANES - Always on Overlay or Main? Usually static grid is best on overlay to avoid smearing
        // But if trailsOnGrid is requested, maybe user wants everything to trail?
        // Let's put Static Grid on Overlay usually, unless trailsOnGrid is specifically requested for all grid elements.
        // For now, let's keep static lanes on Overlay for cleanliness unless Trails requested.

        if(showGrid) {
             const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
             for(let i=Math.floor(startKey); i<endKey; i++) {
                const x = Math.floor((i-startKey)*keyW);
                const w = Math.ceil(keyW);

                targetCtx.save(); targetCtx.shadowBlur=0;
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);
                targetCtx.fillStyle = isBlack ? 'rgba(255,255,255,0.03)' : 'transparent';
                targetCtx.fillRect(x, 0, w, mainCanvas.height);
                targetCtx.strokeStyle = 'rgba(255,255,255,0.05)';
                targetCtx.beginPath(); targetCtx.moveTo(x,0); targetCtx.lineTo(x,mainCanvas.height); targetCtx.stroke();
                targetCtx.restore();
             }
        }
    }

    // --- MK21 RENDER LOGIC ---
    function drawBigCCs(now, isVertical) {
        const targetCtx = overlayTrails ? mainCtx : overlayCtx;
        const gridCtx = overlayCtx; // Grid always fresh
        targetCtx.save();
        gridCtx.save();

        if(ccGlow) targetCtx.shadowBlur = 20;

        const count = bigCCs.size;
        // Total Height/Width available for graphs
        // We want to center them.
        // Each graph height/width is determined by canvas size / count * scale.

        let laneSize, totalSize, centerOffset;

        if (isVertical) {
            // Vertical Mode: Lane = Width slice.
            // Scale increases Width of Lane.
            // Wait, if scale > 1, total width > canvas width? Yes, centered.
            const baseLaneW = mainCanvas.width / count;
            laneSize = baseLaneW * ccScale;
            totalSize = laneSize * count;
            centerOffset = (mainCanvas.width - totalSize) / 2;
        } else {
            // Horizontal Mode: Lane = Height slice.
            const baseLaneH = mainCanvas.height / count;
            laneSize = baseLaneH * ccScale;
            totalSize = laneSize * count;
            centerOffset = (mainCanvas.height - totalSize) / 2;
        }

        // PADDING
        const PAD = 4;
        const drawSize = laneSize - PAD;

        let idx = 0;
        bigCCs.forEach(id => {
             const mon = ccMonitors.get(id);
             if(!mon) return;

             // 1. Determine Lane Boundaries
             let laneStart, laneEnd;
             // Vertical: X coordinates. Horizontal: Y coordinates.

             if (isVertical) {
                 laneStart = centerOffset + (idx * laneSize) + (PAD/2);
                 laneEnd = laneStart + drawSize;
             } else {
                 laneStart = centerOffset + (idx * laneSize) + (PAD/2);
                 laneEnd = laneStart + drawSize;
             }

             // 2. Determine Min/Max for Clamping
             let minVal = 0, maxVal = 127;
             if(ccClamp) {
                 // Scan history for min/max
                 let min = 127, max = 0;
                 if(mon.history.length > 0) {
                     for(const p of mon.history) {
                         if(p.v < min) min = p.v;
                         if(p.v > max) max = p.v;
                     }
                 } else {
                     min = mon.val; max = mon.val;
                 }
                 // Add current val
                 if(mon.val < min) min = mon.val;
                 if(mon.val > max) max = mon.val;

                 // Add buffer?
                 minVal = Math.max(0, min);
                 maxVal = Math.min(127, max);

                 if(minVal === maxVal) { minVal = 0; maxVal = 127; } // Fallback if flat
             }

             const range = maxVal - minVal;

             // Helper to map value 0-127 to pixel pos within lane
             const mapVal = (v) => {
                 // Clamp v first if coming from stream?
                 // No, map to range.
                 // Normalize to 0-1 based on min/max
                 let n = (v - minVal) / (range || 1); // Avoid div0
                 n = Math.max(0, Math.min(1, n));
                 return n;
             };

             // 3. Draw Grid (Fresh Layer)
             if(document.getElementById('chk-cc-grid').checked) {
                 // Use labelSize for grid font size
                 gridCtx.font = `${labelSize}px monospace`;
                 gridCtx.fillStyle = 'rgba(255,255,255,0.5)';

                 for(let v = 0; v <= 127; v += ccGridDensity) {
                     if (v < minVal || v > maxVal) continue;
                     const n = mapVal(v);

                     // Thicker bars for boundaries
                     const isBoundary = (v === 0 || v === 127);
                     gridCtx.lineWidth = isBoundary ? 2 : 1;
                     gridCtx.strokeStyle = isBoundary ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.2)';

                     if(isVertical) {
                         // Vertical Mode: Lines are Vertical (Value is X)
                         const x = laneStart + (n * drawSize);
                         gridCtx.beginPath();
                         gridCtx.moveTo(x, 0);
                         gridCtx.lineTo(x, mainCanvas.height);
                         gridCtx.stroke();
                         // Offset label if sidebar bottom
                         const sbBottom = document.getElementById('main-workspace').classList.contains('sidebar-bottom');
                         gridCtx.fillText(v, x + 2, mainCanvas.height - (sbBottom ? 30 : 10));
                     } else {
                         // Horizontal Mode: Lines are Horizontal (Value is Y)
                         const y = laneEnd - (n * drawSize);
                         gridCtx.beginPath();
                         gridCtx.moveTo(0, y);
                         gridCtx.lineTo(mainCanvas.width, y);
                         gridCtx.stroke();
                         gridCtx.fillText(v, 5, y - 2);
                     }
                 }

                 // Draw Min/Max bounds if clamped
                 if(ccClamp) {
                     gridCtx.strokeStyle = 'rgba(255,0,0,0.3)';
                     if(isVertical) {
                         gridCtx.strokeRect(laneStart, 0, drawSize, mainCanvas.height);
                     } else {
                         gridCtx.strokeRect(0, laneStart, mainCanvas.width, drawSize);
                     }
                 }
             }

             // 4. Draw Graph
             if(ccGlow) targetCtx.shadowColor = mon.color;
             targetCtx.strokeStyle = mon.color;
             targetCtx.lineWidth = overlayThick;
             targetCtx.globalAlpha = ccOpacity;
             targetCtx.beginPath();

             // SMOOTHING PRE-CALC
             // Moving Average Window
             // We need to map active history to screen coords first
             // Or smooth values then map? Smooth values.

             let points = [...mon.history];
             points.push({t: now, v: mon.val});

             // Filter Points by Time to reduce processing?
             // windowSize is 5000ms.
             const windowSize = 5000;
             const startTime = now - windowSize;
             points = points.filter(p => p.t >= startTime);

             if(points.length > 1) {
                 const coords = [];

                 // Moving Average Logic
                 // Simple approach: For each point, avg with N prev points
                 // Better: Sliding Window on Value.

                 const smoothedPoints = [];
                 if(ccSmoothWindow > 1) {
                     for(let i=0; i<points.length; i++) {
                         let sum = 0;
                         let c = 0;
                         for(let j=0; j<ccSmoothWindow; j++) {
                             if(i-j >= 0) {
                                 sum += points[i-j].v;
                                 c++;
                             }
                         }
                         smoothedPoints.push({t: points[i].t, v: sum/c});
                     }
                 } else {
                     smoothedPoints.push(...points);
                 }

                 // Generate Coords
                 for(let p of smoothedPoints) {
                     const dist = (now - p.t) * (noteSpeed / 16.66);
                     // Mapping
                     const n = mapVal(p.v);

                     if (isVertical) {
                         // Y is Time (Top=0 or Bottom=0 depends on direction)
                         let y;
                         if (direction === 'down') y = dist;
                         else y = mainCanvas.height - dist;

                         const x = laneStart + (n * drawSize);
                         coords.push({x, y});
                     } else {
                         // X is Time
                         let x;
                         if (direction === 'right') x = dist;
                         else x = mainCanvas.width - dist;

                         // Y is Value (0 bottom, 127 top)
                         const y = laneEnd - (n * drawSize);
                         coords.push({x, y});
                     }
                 }

                 // Filter out of bounds time
                 const validCoords = coords.filter(c => {
                     if(isVertical) return c.y >= -10 && c.y <= mainCanvas.height + 10;
                     else return c.x >= -10 && c.x <= mainCanvas.width + 10;
                 });

                 if(validCoords.length > 0) {
                      if(overlaySmooth > 0 && validCoords.length > 2) {
                             targetCtx.moveTo(validCoords[0].x, validCoords[0].y);
                             for (let i = 1; i < validCoords.length - 1; i ++) {
                                const xc = (validCoords[i].x + validCoords[i+1].x) / 2;
                                const yc = (validCoords[i].y + validCoords[i+1].y) / 2;
                                targetCtx.quadraticCurveTo(validCoords[i].x, validCoords[i].y, xc, yc);
                             }
                             targetCtx.lineTo(validCoords[validCoords.length-1].x, validCoords[validCoords.length-1].y);
                      } else {
                             targetCtx.moveTo(validCoords[0].x, validCoords[0].y);
                             for(let i=1; i<validCoords.length; i++) targetCtx.lineTo(validCoords[i].x, validCoords[i].y);
                      }
                      targetCtx.stroke();
                 }
             }

             // Label
             overlayCtx.save();
             overlayCtx.fillStyle = mon.color;
             overlayCtx.font = `bold ${labelSize}px ${currentFontStack}`;

             if(isVertical) {
                 const labelY = (direction==='down') ? 45 : mainCanvas.height - 30;
                 overlayCtx.fillText(mon.label || `CC ${mon.cc}`, laneStart + 5, labelY);
             } else {
                 const labelX = (direction==='right') ? 30 : mainCanvas.width - 100;
                 // Center in lane height?
                 overlayCtx.fillText(mon.label || `CC ${mon.cc}`, labelX, laneStart + 20);
             }
             overlayCtx.restore();

             idx++;
        });

        targetCtx.restore();
        gridCtx.restore();
    }

    function drawHorizontal(startKey, endKey, visKeys, moveDist, keyW, bounds = {x:0,y:0,w:mainCanvas.width, h:mainCanvas.height}, filterCh = null) {
        // keyW here is actually keyHeight
        const keyH = keyW;
        const thickH = keyH * (noteThickness / 100);
        const thickOffset = (keyH - thickH) / 2;

        // PIANO
        if(showPiano) {
            pianoCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--panel-bg');
            pianoCtx.fillRect(0, bounds.y, pianoCanvas.width, bounds.h);

            for(let i=Math.floor(startKey); i<endKey; i++) {
                const y = bounds.y + bounds.h - (i - startKey + 1) * keyH;
                const h = Math.ceil(keyH);
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);
                const noteName = CONFIG.NOTE_NAMES[i%12];

                pianoCtx.fillStyle = isBlack ? '#222' : '#888';
                pianoCtx.fillRect(isBlack?0:0, y, isBlack?20:38, h-1);

                pianoCtx.fillStyle = '#fff';
                pianoCtx.font = `bold ${fontScale*0.9}px ${currentFontStack}`;

                if(noteName === "C") {
                    const octave = Math.floor(i/12) - 1;
                    pianoCtx.fillText("C"+octave, 22, y + h - 4);
                }
                else if(showLabels || (!isBlack && keyH > 12)) {
                    if(keyH > 12) pianoCtx.fillText(noteName, 22, y + h - 4);
                }
            }
        }

        // C-LINES
        if(showCLines && !showPiano) {
             for(let i=Math.floor(startKey); i<endKey; i++) {
                 if(i%12===0) {
                    const y = bounds.y + bounds.h - (i - startKey + 1) * keyH;
                    const h = Math.ceil(keyH);
                    mainCtx.save(); mainCtx.strokeStyle='rgba(255,255,255,0.1)';
                    mainCtx.beginPath(); mainCtx.moveTo(0,y+h); mainCtx.lineTo(mainCanvas.width,y+h); mainCtx.stroke();
                    mainCtx.fillStyle = 'rgba(255,255,255,0.5)';
                    mainCtx.font = `bold ${fontScale}px ${currentFontStack}`;
                    const lblX = (direction === 'right') ? 5 : mainCanvas.width - 25;
                    mainCtx.fillText("C"+(Math.floor(i/12)-1), lblX, y + h - 5);
                    mainCtx.restore();
                 }
             }
        }

        // FALLING
        const now = performance.now();

        for(let i=fallingObjects.length-1; i>=0; i--) {
            const o = fallingObjects[i];

            if (filterCh !== null) {
                if (o.type === 'note' && o.ch !== filterCh) continue;
                if (o.type === 'pgm' && o.ch !== filterCh) continue;
            }

            if(o.type === 'grid') {
                const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;
                targetCtx.strokeStyle = o.isBar ? getComputedStyle(document.body).getPropertyValue('--grid-bar') : getComputedStyle(document.body).getPropertyValue('--grid-beat');
                targetCtx.lineWidth = o.isBar ? barThickness : 1;
                targetCtx.beginPath();

                if (direction === 'right') {
                    targetCtx.moveTo(o.pos, bounds.y); targetCtx.lineTo(o.pos, bounds.y + bounds.h);
                } else { // LEFT
                    const x = mainCanvas.width - o.pos;
                    targetCtx.moveTo(x, bounds.y); targetCtx.lineTo(x, bounds.y + bounds.h);
                }
                targetCtx.stroke();
                targetCtx.restore();
            }
            else if(o.type === 'pgm') {
                if(!showPGM) continue;
                const targetCtx = freshPGM ? overlayCtx : mainCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;

                const pgmCol = getNoteColor(o.val, o.val % 16);
                targetCtx.fillStyle = pgmCol;
                targetCtx.globalAlpha = 0.4;

                let px;
                if(direction === 'right') px = o.pos;
                else px = mainCanvas.width - o.pos;

                targetCtx.fillRect(px, bounds.y, 4, bounds.h);
                targetCtx.globalAlpha = 1.0;

                targetCtx.font = `bold ${labelSize}px ${currentFontStack}`;
                targetCtx.fillStyle = pgmCol;
                targetCtx.fillText(`PGM ${o.val}`, px + 5, bounds.y + 20);
                targetCtx.restore();
            }
            else if(o.type === 'note') {
                if(o.note < startKey || o.note >= endKey) continue;
                const y = bounds.y + bounds.h - (o.note - startKey + 1) * keyH + thickOffset;

                mainCtx.save();
                if(document.getElementById('chk-vel-opacity').checked && o.vel !== undefined) {
                    const op = velOpacityBase + (o.vel / 127) * (1 - velOpacityBase);
                    mainCtx.globalAlpha = op;
                }
                if(glowEnabled && glowAmount > 0) {
                    mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : o.color;
                    mainCtx.shadowBlur = glowAmount;
                }
                mainCtx.fillStyle = o.color;

                let rx;
                if (direction === 'right') { rx = o.pos; }
                else { rx = mainCanvas.width - o.pos - o.len; }

                drawNoteShape(mainCtx, rx, y, o.len, Math.ceil(thickH), noteShape);
                mainCtx.restore();

                if(showLabels && keyH > 15) {
                    if (!labelPerBar || o.showLabel !== false) {
                        const targetCtx = freshLabels ? overlayCtx : mainCtx;
                        targetCtx.save(); targetCtx.shadowBlur=0;
                        targetCtx.fillStyle = (labelColorMode === 'match') ? o.color : '#fff';
                        targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                        let lx;
                        if (direction === 'right') lx = o.pos + o.len + 5;
                        else lx = (mainCanvas.width - o.pos - o.len) - 15;

                        targetCtx.fillText(CONFIG.NOTE_NAMES[o.note%12], lx, y + keyH/2 + 4);
                        targetCtx.restore();
                    }
                }
            }
        }

        // BIG CC OVERLAY - handled in loop for Split Mode, or global
        // This function is for standard mode or single strip note drawing.
        // We will remove the call to drawBigCCs from here if perChannelMode,
        // but if not perChannelMode, we call it globally in loop.
        // So we can remove it from here entirely and let loop handle it?
        // Previously drawBigCCs was called here. Now loop handles it for both modes.
        // Wait, loop calls drawBigCCs for standard mode.
        // So I can remove it from here safely.

        // ACTIVE
        activeNotes.forEach(n => {
            if (filterCh !== null && n.ch !== filterCh) return;
            if(n.note < startKey || n.note >= endKey) return;
            const y = bounds.y + bounds.h - (n.note - startKey + 1) * keyH + thickOffset;
            const duration = performance.now() - n.start;
            const len = noteSpeed * (duration / 16.66);

            mainCtx.save();
            if(document.getElementById('chk-vel-opacity').checked) {
                const op = velOpacityBase + (n.vel / 127) * (1 - velOpacityBase);
                mainCtx.globalAlpha = op;
            }
            if(glowEnabled && glowAmount > 0) {
                mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : n.color;
                mainCtx.shadowBlur = glowAmount;
            }
            mainCtx.fillStyle = n.color;

            let rx;
            if (direction === 'right') { rx = 0; }
            else { rx = mainCanvas.width - len; }

            drawNoteShape(mainCtx, rx, y, len, Math.ceil(thickH), noteShape);
            mainCtx.restore();

            if(showLabels && keyH > 15) {
                if(!labelPerBar || n.showLabel !== false) {
                    const targetCtx = freshLabels ? overlayCtx : mainCtx;
                    targetCtx.save(); targetCtx.shadowBlur=0;
                    targetCtx.fillStyle = (labelColorMode === 'match') ? n.color : '#fff';
                    targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                    let lx;
                    if (direction === 'right') lx = len + 5;
                    else lx = (mainCanvas.width - len) - 15;

                    targetCtx.fillText(CONFIG.NOTE_NAMES[n.note%12], lx, y + keyH/2 + 4);
                    targetCtx.restore();
                }
            }
        });

        // GRID LANES
        if(showGrid) {
             const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
             for(let i=Math.floor(startKey); i<endKey; i++) {
                const y = bounds.y + bounds.h - (i - startKey + 1) * keyH;
                const h = Math.ceil(keyH);
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);

                targetCtx.save(); targetCtx.shadowBlur=0;
                targetCtx.fillStyle = isBlack ? 'rgba(255,255,255,0.03)' : 'transparent';
                targetCtx.fillRect(0, y, mainCanvas.width, h);
                targetCtx.strokeStyle = 'rgba(255,255,255,0.05)';
                targetCtx.beginPath(); targetCtx.moveTo(0,y+h); targetCtx.lineTo(mainCanvas.width,y+h); targetCtx.stroke();
                targetCtx.restore();
             }
        }
    }

    function drawBigCCsSplit(now, isVertical, bounds, filterCh) {
        const targetCtx = overlayTrails ? mainCtx : overlayCtx;
        const gridCtx = overlayCtx;
        targetCtx.save();
        gridCtx.save();

        // Clip to bounds
        const clipPath = new Path2D();
        clipPath.rect(bounds.x, bounds.y, bounds.w, bounds.h);
        targetCtx.clip(clipPath);
        gridCtx.clip(clipPath);

        if(ccGlow) targetCtx.shadowBlur = 20;

        // Filter BigCCs for this channel
        const activeIds = [];
        bigCCs.forEach(id => {
            const mon = ccMonitors.get(id);
            if(mon && mon.ch === filterCh) activeIds.push(id);
        });

        if (activeIds.length === 0) {
            targetCtx.restore(); gridCtx.restore(); return;
        }

        // Render Logic - Stacked or Overlaid?
        // "show me channel 12 CC ... and accompanying notes"
        // Usually overlaid on top of notes is best for single strip.
        // We will overlay them all in the strip bounds.

        // Padding for Text
        // Check Sidebar Bottom for label offset
        const sidebarBottom = document.getElementById('main-workspace').classList.contains('sidebar-bottom') && document.getElementById('sidebar').classList.contains('visible');
        const bottomOffset = (sidebarBottom && isVertical) ? 200 : 0; // Rough offset if sidebar overlaps canvas?
        // Actually, canvas is resized when sidebar opens, so we don't need offset unless drawing goes off edge.
        // But user said labels are hidden. This likely means they are drawn at Y=height which is covered?
        // No, canvas height shrinks. But maybe the "0" label is too close to bottom edge.

        const PAD_B = 15; // Bottom padding for text

        activeIds.forEach(id => {
             const mon = ccMonitors.get(id);

             // Min/Max Clamping per Graph? Or Global?
             // Use same logic as main drawBigCCs
             let minVal = 0, maxVal = 127;
             if(ccClamp) {
                 let min = 127, max = 0;
                 if(mon.history.length > 0) {
                     for(const p of mon.history) {
                         if(p.v < min) min = p.v;
                         if(p.v > max) max = p.v;
                     }
                 } else { min = mon.val; max = mon.val; }
                 if(mon.val < min) min = mon.val;
                 if(mon.val > max) max = mon.val;
                 minVal = Math.max(0, min);
                 maxVal = Math.min(127, max);
                 if(minVal === maxVal) { minVal = 0; maxVal = 127; }
             }
             const range = maxVal - minVal;
             const mapVal = (v) => {
                 let n = (v - minVal) / (range || 1);
                 return Math.max(0, Math.min(1, n));
             };

             // Draw Grid
             if(document.getElementById('chk-cc-grid').checked) {
                 gridCtx.font = `${labelSize}px monospace`;
                 gridCtx.fillStyle = 'rgba(255,255,255,0.5)';

                 for(let v = 0; v <= 127; v += ccGridDensity) {
                     if (v < minVal || v > maxVal) continue;
                     const n = mapVal(v);

                     // Thicker bars for boundaries
                     const isBoundary = (v === 0 || v === 127);
                     gridCtx.lineWidth = isBoundary ? 2 : 1;
                     gridCtx.strokeStyle = isBoundary ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.2)';

                     if(isVertical) {
                         const x = bounds.x + (n * (bounds.w - 4));
                         gridCtx.beginPath();
                         gridCtx.moveTo(x, bounds.y);
                         gridCtx.lineTo(x, bounds.y + bounds.h);
                         gridCtx.stroke();

                         const labelY = (direction==='down') ? bounds.y + bounds.h - 10 : bounds.y + bounds.h - 10 - bottomOffset;
                         gridCtx.fillText(v, x + 2, labelY);
                     } else {
                         const y = bounds.y + bounds.h - (n * (bounds.h - 4));
                         gridCtx.beginPath();
                         gridCtx.moveTo(bounds.x, y);
                         gridCtx.lineTo(bounds.x + bounds.w, y);
                         gridCtx.stroke();
                         gridCtx.fillText(v, bounds.x + 5, y - 2);
                     }
                 }
             }

             // Draw Graph
             if(ccGlow) targetCtx.shadowColor = mon.color;
             targetCtx.strokeStyle = mon.color;
             targetCtx.lineWidth = overlayThick;
             targetCtx.globalAlpha = ccOpacity;
             targetCtx.beginPath();

             let points = [...mon.history];
             points.push({t: now, v: mon.val});

             // Dynamic Window
             let windowSize = 5000;
             const dim = isVertical ? bounds.w : bounds.h; // ?? No, time dimension
             // Vertical: Time is Y axis? No, Time is Vertical in Vertical Mode.
             // Wait, in drawVertical:
             // if direction=down: y = o.pos. o.pos += moveDist.
             // moveDist = speed * dt.
             // So Time maps to Height.

             // Window Size (Time duration visible on screen)
             // H = T * Speed / 16.66  -> T = H * 16.66 / Speed
             const timeDim = isVertical ? bounds.h : bounds.w;
             if (noteSpeed > 0) {
                 windowSize = (timeDim * 16.66 / noteSpeed) * 1.1;
                 if(windowSize < 1000) windowSize = 1000;
             }

             const startTime = now - windowSize;
             points = points.filter(p => p.t >= startTime);

             // Smooth
             const smoothedPoints = [];
             if(ccSmoothWindow > 1 && points.length > 0) {
                 for(let i=0; i<points.length; i++) {
                     let sum = 0, c = 0;
                     for(let j=0; j<ccSmoothWindow; j++) {
                         if(i-j >= 0) { sum += points[i-j].v; c++; }
                     }
                     smoothedPoints.push({t: points[i].t, v: sum/c});
                 }
             } else smoothedPoints.push(...points);

             const coords = [];
             for(let p of smoothedPoints) {
                 const dist = (now - p.t) * (noteSpeed / 16.66);
                 const n = mapVal(p.v);

                 if (isVertical) {
                     // Y is Time
                     let y;
                     if (direction === 'down') y = dist;
                     else y = bounds.h - dist; // Relative to bounds

                     // X is Value (width of strip)
                     // bounds.x is left. bounds.w is width.
                     const x = bounds.x + (n * (bounds.w - 4));
                     coords.push({x, y: bounds.y + y});
                 } else {
                     // X is Time
                     let x;
                     if (direction === 'right') x = dist;
                     else x = bounds.w - dist;

                     // Y is Value
                     const y = bounds.y + bounds.h - (n * (bounds.h - 4));
                     coords.push({x: bounds.x + x, y});
                 }
             }

             if(coords.length > 0) {
                  // Draw
                  if(overlaySmooth > 0 && coords.length > 2) {
                         targetCtx.moveTo(coords[0].x, coords[0].y);
                         for (let i = 1; i < coords.length - 1; i ++) {
                            const xc = (coords[i].x + coords[i+1].x) / 2;
                            const yc = (coords[i].y + coords[i+1].y) / 2;
                            targetCtx.quadraticCurveTo(coords[i].x, coords[i].y, xc, yc);
                         }
                         targetCtx.lineTo(coords[coords.length-1].x, coords[coords.length-1].y);
                  } else {
                         targetCtx.moveTo(coords[0].x, coords[0].y);
                         for(let i=1; i<coords.length; i++) targetCtx.lineTo(coords[i].x, coords[i].y);
                  }
                  targetCtx.stroke();
             }

             // Label
             overlayCtx.save();
             overlayCtx.fillStyle = mon.color;
             overlayCtx.font = `bold ${labelSize}px ${currentFontStack}`;
             if(isVertical) {
                 const labelY = (direction==='down') ? bounds.y + 45 : bounds.y + bounds.h - 30 - bottomOffset;
                 overlayCtx.fillText(mon.label || `CC ${mon.cc}`, bounds.x + 5, labelY);
             } else {
                 // Horizontal
                 overlayCtx.fillText(mon.label || `CC ${mon.cc}`, bounds.x + 30, bounds.y + 20);
             }
             overlayCtx.restore();
        });

        targetCtx.restore();
        gridCtx.restore();
    }

    init();
</script>
</body>
</html>