<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATHEDRAL COMMANDER // MK XX</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@500;700&family=VT323&family=Nosifer&family=Playfair+Display:wght@700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- CORE VARIABLES --- */
        :root {
            --bg-color: #050505;
            --panel-bg: #0a0a0a;
            --text-color: #00ff41;
            --accent-color: #ff0055;
            --data-color: #00ccff;
            --grid-beat: #222;
            --grid-bar: #666;
            --font-stack: 'Rajdhani', sans-serif;
            --font-size-base: 13px;
            --cc-graph-width: 150px;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: var(--font-size-base);
            transition: background 0.3s, color 0.3s;
        }

        /* --- HEADER --- */
        header {
            height: 50px;
            background: var(--panel-bg);
            border-bottom: 2px solid var(--text-color);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            z-index: 20;
            flex-shrink: 0;
            justify-content: space-between;
            transition: background 0.3s, border 0.3s;
        }

        h1 {
            margin: 0; font-size: calc(var(--font-size-base) * 1.4); letter-spacing: 3px;
            color: var(--accent-color); font-weight: 700; white-space: nowrap;
            text-transform: uppercase;
        }

        .header-left, .header-right { display: flex; align-items: center; gap: 10px; }

        /* CONTROLS */
        select, button, input[type=number] {
            background: #000; color: var(--text-color); border: 1px solid #333;
            padding: 4px 8px; font-family: var(--font-stack); font-size: var(--font-size-base);
            text-transform: uppercase; cursor: pointer; letter-spacing: 1px;
            outline: none;
        }
        /* Fix Dropdown Border Color */
        select { border-color: var(--text-color); }

        button:hover, select:hover { background: #222; border-color: var(--text-color); }
        button.active { background: var(--text-color); color: #000; font-weight: bold; box-shadow: 0 0 10px var(--text-color); }
        button.icon-btn { font-size: calc(var(--font-size-base) * 1.2); padding: 2px 8px; }

        .control-group {
            display: flex; flex-direction: column; justify-content: center;
            border-right: 1px solid #333; padding-right: 15px; height: 36px;
        }
        .control-group.no-border { border: none; }

        /* SLIDERS */
        .range-wrap { display: flex; flex-direction: column; gap: 2px; }
        .range-wrap label { font-size: calc(var(--font-size-base) * 0.7); color: #666; letter-spacing: 1px; }
        input[type=range] {
            width: 100px; height: 4px; background: #333; appearance: none; cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            appearance: none; width: 10px; height: 10px; background: var(--text-color);
        }

        /* --- SETTINGS PANEL --- */
        #settings-panel {
            position: absolute; top: 50px; left: 0; width: 100%;
            background: var(--panel-bg); border-bottom: 2px solid var(--text-color);
            padding: 15px; display: none; z-index: 19;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.8);
            max-height: calc(100vh - 60px); overflow-y: auto;
        }
        #settings-panel.open { display: grid; }

        .setting-col { display: flex; flex-direction: column; gap: 8px; }
        .setting-col h3 { margin: 0 0 5px 0; font-size: var(--font-size-base); color: var(--accent-color); border-bottom: 1px solid #333; padding-bottom: 2px;}
        .setting-row { display: flex; justify-content: space-between; align-items: center; }
        .setting-row label { font-size: calc(var(--font-size-base) * 0.9); color: #aaa; }

        .sig-inputs { display: flex; gap: 5px; align-items: center; }
        .sig-inputs input { width: 40px; text-align: center; }

        /* --- WORKSPACE LAYOUT --- */
        .workspace {
            display: flex; flex-grow: 1; height: calc(100vh - 50px); position: relative;
            overflow: hidden;
            /* Default: Sidebar on Right */
            flex-direction: row;
        }
        .workspace.sidebar-bottom { flex-direction: column; }

        /* VISUALIZER WRAPPER */
        .vis-wrapper {
            flex-grow: 1; position: relative; display: flex;
            overflow: hidden; background: #000;
            flex-direction: column; /* Default Vertical */
        }

        /* Directional Layouts */
        .workspace.dir-down .vis-wrapper { flex-direction: column; }
        .workspace.dir-up .vis-wrapper { flex-direction: column-reverse; }
        .workspace.dir-right .vis-wrapper { flex-direction: row; }
        .workspace.dir-left .vis-wrapper { flex-direction: row-reverse; }

        /* PIANO ROLL */
        #piano-roll-header {
            background: var(--panel-bg); flex-shrink: 0; display: none;
            border-style: solid; border-color: #333; border-width: 0;
        }
        #piano-roll-header.visible { display: block; }

        .workspace.dir-down #piano-roll-header { width: 100%; height: 30px; border-bottom-width: 1px; }
        .workspace.dir-up #piano-roll-header { width: 100%; height: 30px; border-top-width: 1px; }
        .workspace.dir-right #piano-roll-header { width: 40px; height: 100%; border-right-width: 1px; }
        .workspace.dir-left #piano-roll-header { width: 40px; height: 100%; border-left-width: 1px; }

        /* CANVAS */
        #visualizer-container { flex-grow: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* --- SIDEBAR (CC) --- */
        #sidebar {
            background: var(--panel-bg); border-color: var(--text-color); border-style: solid; border-width: 0;
            display: none; flex-direction: column; flex-shrink: 0; z-index: 15; position: relative;
        }
        #sidebar.visible { display: flex; }

        .workspace:not(.sidebar-bottom) #sidebar { width: 300px; border-left-width: 2px; }
        .workspace.sidebar-bottom #sidebar { height: 200px; width: 100%; border-top-width: 2px; }

        .resizer { position: absolute; z-index: 20; background: rgba(255,255,255,0.05); }
        .resizer:hover { background: var(--accent-color); }

        .workspace:not(.sidebar-bottom) .resizer { width: 5px; cursor: col-resize; left: 0; top: 0; bottom: 0; }
        .workspace.sidebar-bottom .resizer { height: 5px; cursor: row-resize; top: 0; left: 0; right: 0; }

        .sidebar-header {
            padding: 8px; background: rgba(0,0,0,0.2); font-weight: 700;
            border-bottom: 1px solid #333; letter-spacing: 1px;
            display: flex; justify-content: space-between; align-items: center;
        }

        #big-cc-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .workspace.sidebar-bottom #big-cc-controls {
            flex-direction: column;
            position: absolute;
            right: 10px;
            top: 60px;
        }

        .workspace.sidebar-bottom #big-cc-controls input[type=range] {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 8px;
            height: 100px;
            padding: 0 5px;
        }

        #big-cc-scale-value {
            font-size: 12px;
            color: var(--data-color);
            font-family: monospace;
        }

        .sidebar-content {
            flex-grow: 1; overflow-y: auto; padding: 5px;
            display: flex; flex-direction: column; gap: 4px;
        }

        /* Bottom Layout for Sidebar */
        .workspace.sidebar-bottom .sidebar-content {
            flex-direction: row; flex-wrap: wrap; align-content: flex-start;
            overflow-x: auto; /* Allow scroll if needed */
        }

        /* CC WIDGETS */
        .cc-widget {
            background: rgba(0,0,0,0.3); border: 1px solid #333; padding: 0 5px;
            display: flex; align-items: center; height: 40px; gap: 8px;
            animation: flashCC 0.1s ease-out;
            flex-shrink: 0; /* Prevent shrinking in row mode */
            min-width: 120px; /* Hard stop shrinking */
        }
        .cc-widget.hidden { display: none; }
        @keyframes flashCC { from { background: #222; } to { background: rgba(0,0,0,0.3); } }

        .cc-meta { width: 70px; display: flex; flex-direction: column; gap: 2px; pointer-events: none; }
        .cc-label { font-size: calc(var(--font-size-base) * 0.7); color: #666; }
        .cc-name { font-size: calc(var(--font-size-base) * 0.8); font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cc-val-big {
            font-size: calc(var(--font-size-base) * 1.1); color: var(--data-color); font-weight: 700; font-family: monospace;
            width: 35px; text-align: right; flex-shrink: 0; /* Jitter Fix */
        }
        .cc-graph-container {
            flex-grow: 1; height: 30px; background: #000; border: 1px solid #222; position: relative;
            cursor: pointer; /* Click to rename */
            min-width: 50px; /* Prevent total collapse */
        }

        /* Bottom Layout Fixed Width Graphs */
        .workspace.sidebar-bottom .cc-graph-container {
            width: var(--cc-graph-width, 150px);
            flex-grow: 0; flex-shrink: 0;
        }

        .cc-bg-label {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: rgba(255,255,255,0.1); font-weight: 900; pointer-events: none;
            white-space: nowrap;
        }

        .cc-pin-btn {
            width: 12px; height: 12px; border: 1px solid #666; border-radius: 50%;
            cursor: pointer; margin-left: auto;
        }
        .cc-pin-btn.active { background: var(--accent-color); border-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-color); }

        /* CHANNEL MATRIX */
        .ch-matrix { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; width: 200px; display: none; }
        .ch-matrix.visible { display: grid; }
        .ch-led {
            height: 14px; background: #111; border: 1px solid #333;
            font-size: calc(var(--font-size-base) * 0.7); /* Scale Font */
            display: flex; align-items: center; justify-content: center; color: #444;
            transition: background 0.1s, box-shadow 0.1s;
        }

        /* STATUS & BPM */
        #status-box { display: flex; align-items: center; gap: 10px; border: 1px solid #333; padding: 0 10px; height: 30px; }
        #transport-val { font-weight: bold; color: #555; width: 40px; text-align: center; font-size: calc(var(--font-size-base) * 0.9); }
        #bpm-box { display: flex; align-items: center; gap: 5px; }
        #bpm-val { color: var(--accent-color); font-weight: bold; font-size: calc(var(--font-size-base) * 1.2); width: 50px; text-align:right;}
        .bpm-label { font-size: calc(var(--font-size-base) * 0.7); color: #666; }
        #clock-dot { width: 6px; height: 6px; background: #333; border-radius: 50%; }
        #clock-dot.beat { background: var(--text-color); box-shadow: 0 0 8px var(--text-color); }

        /* CRT SCANLINES */
        .crt-scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0) 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10; opacity: 0;
            display: block; /* Always block, opacity controls visibility */
        }
    </style>
</head>
<body>
<header>
    <div class="header-left">
        <h1 id="app-title">MK XX</h1>

        <div class="control-group">
            <select id="midi-input" style="min-width: 150px;"><option>INIT SYSTEMS...</option></select>
        </div>

        <div id="status-box">
            <span id="transport-val">STOP</span>
            <div style="width:1px; height:15px; background:#333" id="transport-div"></div>
            <div id="bpm-box">
                <div id="clock-dot"></div>
                <span id="bpm-val">NO CLOCK</span>
                <span class="bpm-label">BPM</span>
            </div>
        </div>

        <button id="btn-toggle-cc" class="icon-btn active">CC</button>
        <button id="btn-toggle-pgm" class="icon-btn active">PGM</button>

        <div class="ch-matrix visible" id="ch-matrix">
            <!-- JS GEN -->
        </div>
    </div>

    <div class="header-right">
        <!-- QUICK CONTROLS -->
        <div class="range-wrap">
            <label>ZOOM</label>
            <input type="range" id="zoom-slider" min="1" max="8" step="0.1" value="1">
        </div>
        <div class="range-wrap">
            <label>POS</label>
            <input type="range" id="pan-slider" min="0" max="100" step="1" value="30">
        </div>

        <button id="btn-settings" class="icon-btn" style="font-size: 20px;">&#9881;</button>
    </div>
</header>

<!-- SETTINGS PANEL -->
<div id="settings-panel">
    <!-- COL 1: VISUAL FLAVOUR -->
    <div class="setting-col">
        <h3>VISUAL FLAVOUR</h3>
        <div class="setting-row">
            <label>THEME</label>
            <select id="sel-theme">
                <option value="matrix">MATRIX (STD)</option>
                <option value="crave">CRAVE (ORANGE)</option>
                <option value="masseffect">MASS EFFECT N7</option>
                <option value="synthwave">SYNTHWAVE</option>
                <option value="neon">NEON NIGHTS</option>
                <option value="chernobyl">CHERNOBYL (RAD)</option>
                <option value="mono">MONOCHROME</option>
                <option value="warhammer">WARHAMMER 40K</option>
                <option value="helldiver">HELLDIVERS 2</option>
                <option value="elektron">ELEKTRON</option>
                <option value="oxi">OXI INSTRUMENTS</option>
                <option value="sanctuary">SANCTUARY (DIABLO)</option>
                <option value="kerbal">KERBAL SPACE PROGRAM</option>
                <option value="accordion">ACCORDION</option>
                <option value="neve">NEVE CONSOLE</option>
            </select>
        </div>
        <div class="setting-row">
            <label>FONT</label>
            <select id="sel-font">
                <option value="tech">DIN / TECH</option>
                <option value="elegant">IMPERIAL (PLAYFAIR)</option>
                <option value="hacker">TERMINAL</option>
                <option value="gory">GORY (NOSIFER)</option>
                <option value="scifi">SCI-FI (ORBITRON)</option>
                <option value="system">SYSTEM</option>
            </select>
        </div>
        <div class="setting-row">
            <label>NOTE COLOR</label>
            <div style="display:flex; gap:4px;">
                <button id="btn-shuffle-notes" class="icon-btn" title="Shuffle Colors">R</button>
                <select id="sel-color-mode" style="width:80px;">
                    <option value="channel">CHANNEL</option>
                    <option value="octave">OCTAVE</option>
                    <option value="root">ROOT</option>
                    <option value="random">RANDOM</option>
                </select>
            </div>
        </div>
        <div class="setting-row">
            <label>CC COLOR</label>
            <div style="display:flex; gap:4px;">
                <button id="btn-shuffle-cc" class="icon-btn" title="Shuffle Colors">R</button>
                <select id="sel-cc-color-mode" style="width:80px;">
                    <option value="match">MATCH</option>
                    <option value="white">WHITE</option>
                    <option value="matrix">MATRIX</option>
                    <option value="crave">CRAVE</option>
                    <option value="masseffect">MASS EFFECT</option>
                    <option value="synthwave">SYNTHWAVE</option>
                    <option value="neon">NEON</option>
                    <option value="chernobyl">CHERNOBYL</option>
                    <option value="mono">MONO</option>
                    <option value="warhammer">WARHAMMER</option>
                    <option value="helldiver">HELLDIVER</option>
                    <option value="elektron">ELEKTRON</option>
                    <option value="oxi">OXI</option>
                    <option value="sanctuary">SANCTUARY</option>
                    <option value="kerbal">KERBAL</option>
                    <option value="accordion">ACCORDION</option>
                    <option value="neve">NEVE</option>
                    <option value="random">RANDOM</option>
                </select>
            </div>
        </div>
        <div class="setting-row">
            <label>NOTE SHAPE</label>
            <select id="sel-shape">
                <option value="bar">BAR</option>
                <option value="bubble">BUBBLE</option>
                <option value="tear">TEARDROP</option>
                <option value="hex">HEX</option>
            </select>
        </div>
        <div class="setting-row"><label>NOTE WIDTH</label><input type="range" id="thick-slider" min="10" max="200" value="100"></div>
        <div class="setting-row"><label>GLOW ON</label><input type="checkbox" id="chk-glow"></div>
        <div class="setting-row"><label>GLOW AMT</label><input type="range" id="glow-slider" min="0" max="50" value="15"></div>
        <div class="setting-row"><label>BIG CC GLOW</label><input type="checkbox" id="chk-cc-glow"></div>
        <div class="setting-row"><label>BIG CC OPAC</label><input type="range" id="cc-opac-slider" min="0.1" max="1" step="0.1" value="0.6"></div>
        <div class="setting-row"><label>TRAILS</label><input type="range" id="persist-slider" min="0" max="0.9" step="0.01" value="0"></div>
        <div class="setting-row"><label>OVL TRAIL</label><input type="checkbox" id="chk-ovl-trail"></div>
        <div class="setting-row"><label>CRT FX</label><input type="range" id="crt-slider" min="0" max="1" step="0.1" value="0"></div>
        <div class="setting-row"><label>FRESH LABELS</label><input type="checkbox" id="chk-fresh-labels"></div>
        <div class="setting-row"><label>FRESH PGM</label><input type="checkbox" id="chk-fresh-pgm"></div>
    </div>

    <!-- COL 2: DATA DISPLAY -->
    <div class="setting-col">
        <h3>DATA DISPLAY</h3>
        <div class="setting-row"><label>SHOW LABELS</label><input type="checkbox" id="chk-labels"></div>
        <div class="setting-row"><label>LABEL PER BAR</label><input type="checkbox" id="chk-lbl-per-bar"></div>
        <div class="setting-row"><label>LABEL SIZE</label><input type="range" id="lbl-size-slider" min="8" max="32" value="13"></div>
        <div class="setting-row">
            <label>LABEL COL</label>
            <select id="sel-lbl-col">
                <option value="white">WHITE</option>
                <option value="match">MATCH THEME</option>
            </select>
        </div>
    </div>

    <!-- COL 3: OVERLAY & LAYOUT -->
    <div class="setting-col">
        <h3>OVERLAY & LAYOUT</h3>
        <div class="setting-row"><label>UI SIZE</label><input type="range" id="font-size-slider" min="10" max="32" value="13"></div>
        <div class="setting-row">
            <label>CC SIZE</label>
            <div style="display:flex; gap:5px; align-items:center;">
                <input type="range" id="cc-size-slider" min="8" max="24" value="14" style="width:70px;">
                <button id="btn-sync-fonts" class="icon-btn" title="Sync to UI Size">=</button>
            </div>
        </div>
        <div class="setting-row"><label>CC SCALE</label><input type="range" id="cc-scale-slider" min="100" max="300" value="150"></div>
        <div class="setting-row"><label>BAR THICK</label><input type="range" id="grid-thick" min="1" max="8" value="2"></div>
        <div class="setting-row"><label>SPEED</label><input type="range" id="speed-slider" min="1" max="10" value="4"></div>
        <div class="setting-row"><label>OVL SMOOTH</label><input type="range" id="ovl-smooth-slider" min="0" max="20" value="0"></div>
        <div class="setting-row"><label>OVL THICK</label><input type="range" id="ovl-thick-slider" min="1" max="20" value="3"></div>
        <div class="setting-row"><label>DIRECTION</label>
            <select id="sel-direction">
                <option value="down">DOWN (WATERFALL)</option>
                <option value="up">UP (RISING)</option>
                <option value="right">RIGHT (TIMELINE)</option>
                <option value="left">LEFT (REWIND)</option>
            </select>
        </div>
        <div class="setting-row"><label>CC POS</label>
            <select id="sel-sidebar-pos">
                <option value="right">RIGHT SIDE</option>
                <option value="bottom">BOTTOM</option>
            </select>
        </div>
        <div class="setting-row"><label>CC DIRECTION</label>
            <select id="sel-cc-dir">
                <option value="left">SCROLL LEFT</option>
                <option value="right">SCROLL RIGHT</option>
            </select>
        </div>
        <div class="setting-row"><label>TRAILS ON GRID</label><input type="checkbox" id="chk-trails-grid"></div>
    </div>

    <!-- COL 4: SYSTEM & FLIGHT -->
    <div class="setting-col">
        <h3>SYSTEM</h3>
        <div class="setting-row">
            <button id="btn-manual-init" style="width: 100%; color: var(--accent-color);">[ MANUAL INIT MIDI ]</button>
        </div>
        <div class="setting-row">
            <button id="btn-save-cfg" style="width: 48%;">SAVE CFG</button>
            <button id="btn-load-cfg" style="width: 48%;">LOAD CFG</button>
            <input type="file" id="file-input" style="display:none" accept=".json">
        </div>
        <div class="setting-row">
            <button id="btn-save-db" style="width: 48%;">SAVE DB</button>
            <button id="btn-load-db" style="width: 48%;">LOAD DB</button>
            <input type="file" id="db-input" style="display:none" accept=".json">
        </div>

        <h3>FLIGHT DATA</h3>
        <div class="setting-row"><label>SHOW PGM</label><input type="checkbox" id="chk-show-pgm" checked></div>
        <div class="setting-row"><label>TIME SIG</label>
            <div class="sig-inputs">
                <input type="number" id="sig-num" value="4" min="1" max="32"><span>/</span><input type="number" id="sig-den" value="4" min="1" max="32">
            </div>
        </div>
        <div class="setting-row"><label>CC TIMEOUT</label>
            <select id="sel-cc-timeout">
                <option value="0">NEVER</option>
                <option value="2000">2 SEC</option>
                <option value="5000">5 SEC</option>
                <option value="10000">10 SEC</option>
                <option value="60000">60 SEC</option>
            </select>
        </div>
        <div class="setting-row"><label>SHOW SYNC</label><input type="checkbox" id="chk-bpm" checked></div>
        <div class="setting-row"><label>SHOW CC</label><input type="checkbox" id="chk-cc-panel" checked></div>
        <div class="setting-row"><label>SHOW PIANO</label><input type="checkbox" id="chk-piano" checked></div>
        <div class="setting-row"><label>SHOW MATRIX</label><input type="checkbox" id="chk-matrix" checked></div>
        <div class="setting-row"><label>SHOW GRID</label><input type="checkbox" id="chk-grid" checked></div>
        <div class="setting-row"><label>SHOW BARS</label><input type="checkbox" id="chk-bar" checked></div>
        <div class="setting-row"><label>SHOW C-LINES</label><input type="checkbox" id="chk-clines"></div>

        <h3>NOTE CHANNELS</h3>
        <div class="ch-filter-grid" id="ch-filter-container-notes" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px;"></div>
        <h3>CC CHANNELS</h3>
        <div class="ch-filter-grid" id="ch-filter-container-cc" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px;"></div>
    </div>
</div>

<div class="workspace dir-down" id="main-workspace">

    <div class="vis-wrapper" id="vis-wrapper">
        <div id="piano-roll-header" class="visible">
            <canvas id="pianoCanvas"></canvas>
        </div>
        <div id="visualizer-container">
            <div class="crt-scanlines" id="crt-overlay"></div>
            <canvas id="mainCanvas"></canvas>
            <canvas id="overlayCanvas" style="pointer-events:none; position:absolute; top:0; left:0;"></canvas>
        </div>
    </div>

    <div id="sidebar" class="visible">
        <div class="resizer" id="drag-handle"></div>
        <div class="sidebar-header">
            <div style="display:flex; flex-direction:column;">
                <span>CC FLIGHT RECORDER</span>
                <span style="font-size:9px; color:#666; font-weight:normal;">R-CLICK HIDE / DRAG OVL</span>
            </div>
            <div id="big-cc-controls" style="display:none;">
                <div class="range-wrap">
                    <label>Graph Scale</label>
                    <input type="range" id="big-cc-scale-slider" min="0.1" max="1" step="0.05" value="0.5">
                </div>
                <span id="big-cc-scale-value">50%</span>
            </div>
            <div style="display:flex; gap:2px;">
                <button class="icon-btn" onclick="resetCCFilters()" title="Show All">ALL</button>
                <button class="icon-btn" onclick="clearCC()" title="Clear Data">CLR</button>
            </div>
        </div>
        <div class="sidebar-content" id="cc-container">
            <div style="text-align:center; color:var(--text-color); opacity:0.5; font-size:10px; padding-top:20px;">NO SIGNAL</div>
        </div>
    </div>

</div>
<script>
    /**
     * CATHEDRAL COMMANDER MK XX
     * "VIENNA VANGUARD" EDITION
     */

    // --- CONFIG ---
    const THEMES = {
        matrix: { bg:'#050505', panel:'#0a0a0a', text:'#00ff41', accent:'#ff0055', data:'#00ccff', grid:'#222', bar:'#666', ch:['#FF0055','#00FF41','#00CCFF','#FFCC00','#9900FF','#FF6600','#00FFCC','#FF3399','#EEE','#888','#B71C1C','#1B5E20','#33691E','#3E2723','#01579B','#4A148C']},
        crave: { bg:'#1a1a1a', panel:'#222', text:'#F57F17', accent:'#FFCC00', data:'#888', grid:'#333', bar:'#F57F17', ch:['#F57F17','#d1d1d1','#FFCC00','#a0a0a0','#F57F17','#d1d1d1','#FFCC00','#a0a0a0','#F57F17','#d1d1d1','#FFCC00','#a0a0a0','#F57F17','#d1d1d1','#FFCC00','#a0a0a0']},
        masseffect: { bg:'#0b1624', panel:'#131b29', text:'#4DB2FF', accent:'#D9531E', data:'#fff', grid:'#1c2b3d', bar:'#D9531E', ch:['#D9531E','#4DB2FF','#ffffff','#888888','#D9531E','#4DB2FF','#ffffff','#888888','#D9531E','#4DB2FF','#ffffff','#888888','#D9531E','#4DB2FF','#ffffff','#888888']},
        synthwave: { bg:'#12001f', panel:'#1e0033', text:'#00f2ff', accent:'#ff0099', data:'#bd00ff', grid:'#36005c', bar:'#ff0099', ch:['#ff0099','#00f2ff','#bd00ff','#faff00','#ff0099','#00f2ff','#bd00ff','#faff00','#ff0099','#00f2ff','#bd00ff','#faff00','#ff0099','#00f2ff','#bd00ff','#faff00']},
        neon: { bg:'#000', panel:'#000', text:'#0f0', accent:'#f0f', data:'#0ff', grid:'#333', bar:'#fff', ch:['#f00','#0f0','#00f','#ff0','#0ff','#f0f','#fff','#aaa','#f00','#0f0','#00f','#ff0','#0ff','#f0f','#fff','#aaa']},
        mono: { bg:'#000', panel:'#000', text:'#fff', accent:'#fff', data:'#fff', grid:'#333', bar:'#fff', ch:['#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff','#fff']},
        warhammer: { bg:'#0b0500', panel:'#1a0f00', text:'#d4af37', accent:'#8a0000', data:'#7a7a7a', grid:'#2b1d0e', bar:'#8a0000', ch:['#8a0000','#d4af37','#5e5e5e','#ffffff','#8a0000','#d4af37','#5e5e5e','#ffffff','#8a0000','#d4af37','#5e5e5e','#ffffff','#8a0000','#d4af37','#5e5e5e','#ffffff']},
        helldiver: { bg:'#111', panel:'#1a1a1a', text:'#ffe600', accent:'#fff', data:'#aaa', grid:'#333', bar:'#ffe600', ch:['#ffe600','#000','#fff','#ffe600','#333','#fff','#ffe600','#333','#fff','#ffe600','#333','#fff','#ffe600','#333','#fff','#ffe600']},
        elektron: { bg:'#222', panel:'#333', text:'#ff6600', accent:'#ff3333', data:'#aaa', grid:'#444', bar:'#ff6600', ch:['#ff3333','#ff6600','#ffffff','#888','#ff3333','#ff6600','#ffffff','#888','#ff3333','#ff6600','#ffffff','#888','#ff3333','#ff6600','#ffffff','#888']},
        oxi: { bg:'#000', panel:'#111', text:'#fff', accent:'#00ffcc', data:'#ff00ff', grid:'#222', bar:'#fff', ch:['#ff99cc','#99ccff','#99ffcc','#ffff99','#cc99ff','#ffcc99','#fff','#888','#ff99cc','#99ccff','#99ffcc','#ffff99','#cc99ff','#ffcc99','#fff','#888']},
        lsd: { bg:'#000', panel:'#100020', text:'#00ff00', accent:'#ff00ff', data:'#00ffff', grid:'#222', bar:'#fff', ch:['#f00','#ff8000','#ff0','#80ff00','#0f0','#00ff80','#0ff','#0080ff','#00f','#8000ff','#f0f','#ff0080','#fff','#888','#444','#000']},
        sanctuary: { bg:'#050000', panel:'#1a0000', text:'#c20000', accent:'#ffcc00', data:'#590000', grid:'#220000', bar:'#8a0000', ch:['#8a0000','#ff2200','#ffcc00','#440000','#8a0000','#ff2200','#ffcc00','#440000','#8a0000','#ff2200','#ffcc00','#440000','#8a0000','#ff2200','#ffcc00','#440000']},
        kerbal: { bg:'#222', panel:'#333', text:'#BADA55', accent:'#fff', data:'#888', grid:'#444', bar:'#BADA55', ch:['#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55','#fff','#888','#BADA55']},
        chernobyl: { bg:'#000000', panel:'#050505', text:'#00ffff', accent:'#0099ff', data:'#0055ff', grid:'#111', bar:'#00ffff', ch:['#0ff','#00ccff','#0099ff','#0066ff','#fff','#aaa','#0ff','#00ccff','#0099ff','#0066ff','#fff','#aaa','#0ff','#00ccff','#0099ff','#0066ff']},
        accordion: { bg:'#1a1510', panel:'#2b231a', text:'#e6dcc8', accent:'#8c2626', data:'#111', grid:'#3e3226', bar:'#e6dcc8', ch:['#e6dcc8','#111','#8c2626','#3e3226','#e6dcc8','#111','#8c2626','#3e3226','#e6dcc8','#111','#8c2626','#3e3226','#e6dcc8','#111','#8c2626','#3e3226']},
        neve: { bg:'#2a2f35', panel:'#353b42', text:'#aab2bd', accent:'#bf2e2e', data:'#2e5280', grid:'#444b54', bar:'#bf2e2e', ch:['#2e5280','#bf2e2e','#aab2bd','#2a2f35','#2e5280','#bf2e2e','#aab2bd','#2a2f35','#2e5280','#bf2e2e','#aab2bd','#2a2f35']}
    };

    const CONFIG = {
        NOTE_NAMES: ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
        BLACK_KEYS: [1, 3, 6, 8, 10],
        PPQN: 24
    };

    // --- STATE ---
    let midiAccess = null;
    let selectedInputId = null;

    let currentFontStack = "'Rajdhani', sans-serif";
    let currentTheme = 'matrix';
    let noteSpeed = 4;
    let zoomLevel = 1;
    let panPercent = 30;
    let colorMode = 'channel';
    let ccColorMode = 'match';
    let ccTimeout = 0;
    let showLabels = false;
    let showGrid = true;
    let showBarLines = true;
    let showPiano = true;
    let showCLines = false;
    let glowEnabled = false;
    let glowAmount = 15;
    let ccGlow = false;
    let ccOpacity = 0.6;
    let direction = 'down';
    let persistence = 0;
    let noteThickness = 100;
    let noteShape = 'bar';
    let fontSizeCC = 14;
    let ccScrollDir = 'left';
    let channelMaskNotes = new Array(16).fill(true);
    let channelMaskCC = new Array(16).fill(true);
    let trailsOnGrid = false;
    let bigCCs = new Set();
    let hiddenCCs = new Set();
    let randomPaletteNotes = [];
    let randomPaletteCC = [];

    // New Features State
    let showPGM = true;
    let freshPGM = false;
    let freshLabels = false;
    let labelSize = 13;
    let labelColorMode = 'white';
    let labelPerBar = false;
    let overlaySmooth = 0;
    let overlayThick = 3;
    let overlayTrails = false;
    let ccScale = 150;
    let bigCcGraphScale = 0.5;

    let sigNum = 4;
    let sigDen = 4;
    let barThickness = 2;
    let fontScale = 13;

    // Data
    const activeNotes = new Map();
    const fallingObjects = [];
    const ccMonitors = new Map();
    const chIndicators = [];
    const persistentLabels = new Map(); // Fix Label Loss
    const labeledPitches = new Set(); // Global for "Label Per Bar"

    // Clock
    let clockTicks = 0;
    let lastClockTime = 0;
    let tickHistory = [];
    let lastActiveClock = 0;
    let ticksPerBar = 96;
    let barTickCounter = 0;

    const mainCanvas = document.getElementById('mainCanvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const pianoCanvas = document.getElementById('pianoCanvas');
    const mainCtx = mainCanvas.getContext('2d', { alpha: true });
    const overlayCtx = overlayCanvas.getContext('2d', { alpha: true });
    const pianoCtx = pianoCanvas.getContext('2d', { alpha: false });
    const chContainer = document.getElementById('ch-matrix');

    function init() {
        shuffleColors(randomPaletteNotes);
        shuffleColors(randomPaletteCC);
        setupChannelMatrix();
        setupChannelFilters('ch-filter-container-notes', channelMaskNotes);
        setupChannelFilters('ch-filter-container-cc', channelMaskCC);
        setupEventListeners();
        applyTheme('matrix');
        updateTimeSig();
        updateFont('tech'); // Default to DIN/Tech
        resize();
        window.addEventListener('resize', resize);
        initMIDI();

        setInterval(cleanupCCs, 1000);
        requestAnimationFrame(loop);
    }

    function shuffleColors(arr) {
        arr.length = 0;
        // Generate 16 random vibrant colors
        for(let i=0; i<16; i++) {
            const h = Math.floor(Math.random() * 360);
            const s = 70 + Math.random() * 30;
            const l = 50 + Math.random() * 20;
            arr.push(`hsl(${h}, ${s}%, ${l}%)`);
        }
    }

    function setupChannelMatrix() {
        for(let i=0; i<16; i++) {
            const d = document.createElement('div');
            d.className = 'ch-led';
            d.textContent = i+1;
            chContainer.appendChild(d);
            chIndicators.push(d);
        }
    }

    function setupChannelFilters(containerId, maskArray) {
        const cont = document.getElementById(containerId);
        cont.innerHTML = '';
        for(let i=0; i<16; i++) {
            const wrap = document.createElement('div');
            wrap.style.display = 'flex'; wrap.style.alignItems='center'; wrap.style.gap='2px';
            const cb = document.createElement('input');
            cb.type = 'checkbox'; cb.checked = true;
            cb.id = `${containerId}-mask-${i}`;
            cb.addEventListener('change', e => maskArray[i] = e.target.checked);
            const lbl = document.createElement('span');
            lbl.innerText = (i+1); lbl.style.fontSize='10px'; lbl.style.color='#666';
            wrap.appendChild(cb); wrap.appendChild(lbl);
            cont.appendChild(wrap);
        }
    }

    function applyTheme(key) {
        currentTheme = key;
        const t = THEMES[key];
        const r = document.documentElement.style;
        r.setProperty('--bg-color', t.bg);
        r.setProperty('--panel-bg', t.panel);
        r.setProperty('--text-color', t.text);
        r.setProperty('--accent-color', t.accent);
        r.setProperty('--data-color', t.data);
        r.setProperty('--grid-beat', t.grid);
        r.setProperty('--grid-bar', t.bar);
        document.getElementById('app-title').innerText = `MK XX // ${key.toUpperCase()}`;
    }

    function cleanupCCs() {
        if (ccTimeout === 0) return;
        const now = performance.now();
        ccMonitors.forEach((mon, id) => {
            if (mon.pinned) return; // Ignore pinned
            if (now - mon.lastUpdate > ccTimeout) {
                mon.element.remove();
                ccMonitors.delete(id);
                bigCCs.delete(id);
            }
        });
        if (ccMonitors.size === 0 && document.getElementById('cc-container').children.length === 0) {
             document.getElementById('cc-container').innerHTML = '<div style="text-align:center; color:var(--text-color); opacity:0.5; font-size:10px; padding-top:20px;">NO SIGNAL</div>';
        }
    }

    function setupEventListeners() {
        const safeListen = (id, evt, fn) => {
            const el = document.getElementById(id);
            if(el) el.addEventListener(evt, fn);
        };

        safeListen('zoom-slider', 'input', e => zoomLevel = parseFloat(e.target.value));
        safeListen('pan-slider', 'input', e => panPercent = parseFloat(e.target.value));

        safeListen('btn-settings', 'click', e => {
            const p = document.getElementById('settings-panel');
            if(p) p.classList.toggle('open');
            e.target.classList.toggle('active');
        });

        safeListen('btn-manual-init', 'click', initMIDI);

        safeListen('btn-toggle-cc', 'click', e => {
            const chk = document.getElementById('chk-cc-panel');
            chk.checked = !chk.checked;
            chk.dispatchEvent(new Event('change'));
            e.target.classList.toggle('active');
        });

        safeListen('btn-toggle-pgm', 'click', e => {
             const chk = document.getElementById('chk-show-pgm');
             chk.checked = !chk.checked;
             chk.dispatchEvent(new Event('change'));
             e.target.classList.toggle('active');
        });

        safeListen('btn-shuffle-notes', 'click', () => { shuffleColors(randomPaletteNotes); });
        safeListen('btn-shuffle-cc', 'click', () => { shuffleColors(randomPaletteCC); });

        safeListen('btn-save-cfg', 'click', saveConfig);
        safeListen('btn-load-cfg', 'click', () => document.getElementById('file-input').click());
        safeListen('file-input', 'change', loadConfig);

        safeListen('btn-save-db', 'click', saveCCDatabase);
        safeListen('btn-load-db', 'click', () => document.getElementById('db-input').click());
        safeListen('db-input', 'change', loadCCDatabase);

        const toggle = (id, action) => safeListen(id, 'change', e => action(e.target.checked));
        toggle('chk-bpm', v => {
             const bpmBox = document.getElementById('bpm-box');
             const transDiv = document.getElementById('transport-div');
             const transVal = document.getElementById('transport-val');

             if(v) {
                 bpmBox.style.display = 'flex';
                 transDiv.style.display = 'block';
                 transVal.style.display = 'block';
                 document.getElementById('status-box').style.display = 'flex';
             } else {
                 bpmBox.style.display = 'none';
                 transDiv.style.display = 'none';
                 transVal.style.display = 'none';
                 document.getElementById('status-box').style.display = 'none';
             }
        });
        toggle('chk-matrix', v => document.getElementById('ch-matrix').classList.toggle('visible', v));
        toggle('chk-piano', v => { showPiano = v; document.getElementById('piano-roll-header').classList.toggle('visible', v); resize(); });
        toggle('chk-grid', v => showGrid = v);
        toggle('chk-bar', v => showBarLines = v);
        toggle('chk-labels', v => {
            showLabels = v;
            const btn = document.getElementById('btn-labels');
            if(btn) if(v) btn.classList.add('active'); else btn.classList.remove('active');
        });
        toggle('chk-clines', v => showCLines = v);
        toggle('chk-cc-panel', v => {
            document.getElementById('sidebar').classList.toggle('visible', v);
            const btn = document.getElementById('btn-toggle-cc');
            if(v) btn.classList.add('active'); else btn.classList.remove('active');
            resize();
        });

        safeListen('sel-sidebar-pos', 'change', e => {
            const ws = document.getElementById('main-workspace');
            if (e.target.value === 'bottom') ws.classList.add('sidebar-bottom');
            else ws.classList.remove('sidebar-bottom');
            resize();
        });

        safeListen('sel-direction', 'change', e => {
            direction = e.target.value;
            const ws = document.getElementById('main-workspace');
            ws.className = 'workspace';
            ws.classList.add(`dir-${direction}`);
            if (document.getElementById('sel-sidebar-pos').value === 'bottom') ws.classList.add('sidebar-bottom');
            fallingObjects.length = 0;
            resize();
        });

        safeListen('chk-glow', 'change', e => { if (e.target.checked) glowEnabled = true; else glowEnabled = false; });
        safeListen('chk-cc-glow', 'change', e => ccGlow = e.target.checked);

        safeListen('glow-slider', 'input', e => { if (document.getElementById('chk-glow').checked) glowAmount = parseInt(e.target.value); });
        safeListen('cc-opac-slider', 'input', e => ccOpacity = parseFloat(e.target.value));
        safeListen('persist-slider', 'input', e => persistence = parseFloat(e.target.value));
        safeListen('thick-slider', 'input', e => noteThickness = parseInt(e.target.value));

        // CRT Slider
        safeListen('crt-slider', 'input', e => {
             const val = parseFloat(e.target.value);
             const el = document.getElementById('crt-overlay');
             el.style.opacity = val;
             el.style.display = val > 0 ? 'block' : 'none';
        });

        const sel = (id, action) => safeListen(id, 'change', e => action(e.target.value));
        sel('sel-theme', applyTheme);
        sel('sel-color-mode', v => colorMode = v);
        sel('sel-cc-color-mode', v => ccColorMode = v);
        sel('sel-cc-timeout', v => ccTimeout = parseInt(v));
        sel('sel-font', updateFont);
        sel('sel-shape', v => noteShape = v);
        sel('sel-cc-dir', v => ccScrollDir = v);

        safeListen('speed-slider', 'input', e => noteSpeed = parseInt(e.target.value));
        safeListen('sig-num', 'input', e => { sigNum = parseInt(e.target.value) || 4; updateTimeSig(); });
        safeListen('sig-den', 'input', e => { sigDen = parseInt(e.target.value) || 4; updateTimeSig(); });
        safeListen('grid-thick', 'input', e => barThickness = parseInt(e.target.value));

        safeListen('font-size-slider', 'input', e => {
            fontScale = parseInt(e.target.value);
            document.documentElement.style.setProperty('--font-size-base', fontScale + 'px');
        });
        safeListen('cc-size-slider', 'input', e => {
            fontSizeCC = parseInt(e.target.value);
            document.querySelectorAll('.cc-val-big').forEach(el => el.style.fontSize = fontSizeCC + 'px');
        });
        safeListen('btn-sync-fonts', 'click', () => {
             fontSizeCC = fontScale;
             document.getElementById('cc-size-slider').value = fontSizeCC;
             document.querySelectorAll('.cc-val-big').forEach(el => el.style.fontSize = fontSizeCC + 'px');
        });

        safeListen('chk-trails-grid', 'change', e => trailsOnGrid = e.target.checked);

        // New Features Listeners
        safeListen('chk-show-pgm', 'change', e => {
             showPGM = e.target.checked;
             const btn = document.getElementById('btn-toggle-pgm');
             if(btn) if(e.target.checked) btn.classList.add('active'); else btn.classList.remove('active');
        });
        safeListen('chk-fresh-pgm', 'change', e => freshPGM = e.target.checked);
        safeListen('chk-fresh-labels', 'change', e => freshLabels = e.target.checked);
        safeListen('lbl-size-slider', 'input', e => labelSize = parseInt(e.target.value));
        safeListen('chk-lbl-per-bar', 'change', e => labelPerBar = e.target.checked);
        safeListen('sel-lbl-col', 'change', e => labelColorMode = e.target.value);
        safeListen('ovl-smooth-slider', 'input', e => overlaySmooth = parseInt(e.target.value));
        safeListen('ovl-thick-slider', 'input', e => overlayThick = parseInt(e.target.value));
        safeListen('chk-ovl-trail', 'change', e => overlayTrails = e.target.checked);

        safeListen('cc-scale-slider', 'input', e => {
            ccScale = parseInt(e.target.value);
            document.documentElement.style.setProperty('--cc-graph-width', ccScale + 'px');
            document.querySelectorAll('.cc-widget canvas').forEach(c => {
                c.width = ccScale;
                // Trigger resize logic manually or wait for next update?
                // Ideally we update the 'mon.w' property
                const mon = ccMonitors.get(c.parentElement.parentElement.dataset.id); // brittle selector
                if(mon) mon.w = ccScale;
            });
        });

        safeListen('big-cc-scale-slider', 'input', e => {
            const value = parseFloat(e.target.value);
            bigCcGraphScale = value;
            document.getElementById('big-cc-scale-value').innerText = `${Math.round(value * 100)}%`;
        });

        const handle = document.getElementById('drag-handle');
        const sidebar = document.getElementById('sidebar');
        if(handle && sidebar) {
            let isResizing = false;
            handle.addEventListener('mousedown', () => { isResizing = true; document.body.style.cursor = 'col-resize'; });
            window.addEventListener('mousemove', e => {
                if(!isResizing) return;
                if (document.getElementById('main-workspace').classList.contains('sidebar-bottom')) {
                    sidebar.style.height = (window.innerHeight - e.clientY - 50) + 'px';
                } else {
                    sidebar.style.width = (window.innerWidth - e.clientX) + 'px';
                }
                resize();
            });
            window.addEventListener('mouseup', () => { isResizing = false; document.body.style.cursor = 'default'; });
        }

        // --- MOUSE PAN/ZOOM ---
        const vCont = document.getElementById('visualizer-container');
        let isDraggingMain = false;
        let lastX = 0, lastY = 0;

        vCont.addEventListener('mousedown', e => {
            if(e.button === 0) { // Left Click
                isDraggingMain = true;
                lastX = e.clientX;
                lastY = e.clientY;
                vCont.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', e => {
            if(isDraggingMain) {
                const dx = e.clientX - lastX;
                // const dy = e.clientY - lastY; // Unused for now
                lastX = e.clientX;
                lastY = e.clientY;

                // Adjust PAN
                const sens = 0.2;
                panPercent = Math.max(0, Math.min(100, panPercent - (dx * sens)));
                document.getElementById('pan-slider').value = panPercent;
            }
        });

        window.addEventListener('mouseup', () => {
            isDraggingMain = false;
            vCont.style.cursor = 'default';
        });

        vCont.addEventListener('wheel', e => {
            e.preventDefault();
            const sign = Math.sign(e.deltaY);

            if(direction === 'left' || direction === 'right') {
                 // Horizontal Scroll -> Pan
                 panPercent = Math.max(0, Math.min(100, panPercent + (sign * 2)));
                 document.getElementById('pan-slider').value = panPercent;
            } else {
                 // Vertical Scroll -> Zoom
                 zoomLevel = Math.max(1, Math.min(8, zoomLevel - (sign * 0.1)));
                 document.getElementById('zoom-slider').value = zoomLevel;
            }
        }, {passive: false});

        // --- DRAG & DROP CC ---
        vCont.addEventListener('dragover', e => e.preventDefault());
        vCont.addEventListener('drop', e => {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            if(id && ccMonitors.has(id)) {
                if(bigCCs.has(id)) bigCCs.delete(id);
                else bigCCs.add(id);
            }
            document.getElementById('big-cc-controls').style.display = bigCCs.size > 0 ? 'flex' : 'none';
        });
    }

    function resetCCFilters() {
        hiddenCCs.clear();
        ccMonitors.forEach((mon, id) => {
            mon.element.classList.remove('hidden');
        });
    }

    function saveCCDatabase() {
        // Export persistentLabels map
        const db = Object.fromEntries(persistentLabels);
        const blob = new Blob([JSON.stringify(db, null, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "cc_database.json";
        a.click();
    }

    function loadCCDatabase(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const db = JSON.parse(e.target.result);
                for (const [id, lbl] of Object.entries(db)) {
                    persistentLabels.set(id, lbl);
                    // Update existing widgets if any
                    const mon = ccMonitors.get(id);
                    if(mon) {
                        mon.label = lbl;
                        mon.element.querySelector('.cc-name').innerText = lbl;
                        mon.element.querySelector('.cc-bg-label').innerText = lbl;
                    }
                }
                alert("CC Database Loaded");
            } catch(err) { console.error(err); alert("Invalid DB File"); }
        };
        reader.readAsText(file);
    }

    function saveConfig() {
        // Capture CC Labels
        const ccLabels = {};
        ccMonitors.forEach((mon, id) => {
            if(mon.label) ccLabels[id] = mon.label;
        });

        const cfg = {
            theme: currentTheme,
            noteSpeed, zoomLevel, panPercent, colorMode, ccTimeout,
            showLabels, showGrid, showBarLines, showPiano, showCLines, glowEnabled, glowAmount,
            direction, persistence, noteThickness, noteShape,
            sigNum, sigDen, barThickness, fontScale, fontSizeCC,
            ccScrollDir, channelMaskNotes, channelMaskCC, ccLabels,
            crtOpacity: document.getElementById('crt-slider').value,
            trailsOnGrid,
            showPGM, freshPGM, freshLabels, labelSize, labelColorMode,
            overlaySmooth, overlayThick, overlayTrails, ccColorMode, ccGlow, ccOpacity,
            sidebarPos: document.getElementById('sel-sidebar-pos').value
        };
        const blob = new Blob([JSON.stringify(cfg)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "cathedral_v20_config.json";
        a.click();
    }

    function loadConfig(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if(data.theme) { currentTheme=data.theme; document.getElementById('sel-theme').value=data.theme; applyTheme(data.theme); }
                if(data.noteSpeed) { noteSpeed=data.noteSpeed; document.getElementById('speed-slider').value=data.noteSpeed; }
                if(data.zoomLevel) { zoomLevel=data.zoomLevel; document.getElementById('zoom-slider').value=data.zoomLevel; }
                if(data.panPercent) { panPercent=data.panPercent; document.getElementById('pan-slider').value=data.panPercent; }
                if(data.colorMode) { colorMode=data.colorMode; document.getElementById('sel-color-mode').value=data.colorMode; }
                if(data.ccColorMode) { ccColorMode=data.ccColorMode; document.getElementById('sel-cc-color-mode').value=data.ccColorMode; }

                const setChk = (id, val) => { const el=document.getElementById(id); if(el) { el.checked=val; el.dispatchEvent(new Event('change')); }};
                if(data.showLabels!==undefined) setChk('chk-labels', data.showLabels);
                if(data.showGrid!==undefined) setChk('chk-grid', data.showGrid);
                if(data.showBarLines!==undefined) setChk('chk-bar', data.showBarLines);
                if(data.showPiano!==undefined) setChk('chk-piano', data.showPiano);
                if(data.showCLines!==undefined) setChk('chk-clines', data.showCLines);
                if(data.glowEnabled!==undefined) setChk('chk-glow', data.glowEnabled);

                if(data.glowAmount) { glowAmount=data.glowAmount; document.getElementById('glow-slider').value=data.glowAmount; }
                if(data.persistence) { persistence=data.persistence; document.getElementById('persist-slider').value=data.persistence; }
                if(data.noteThickness) { noteThickness=data.noteThickness; document.getElementById('thick-slider').value=data.noteThickness; }
                if(data.noteShape) { noteShape=data.noteShape; document.getElementById('sel-shape').value=data.noteShape; }

                if(data.sigNum) document.getElementById('sig-num').value = data.sigNum;
                if(data.sigDen) document.getElementById('sig-den').value = data.sigDen;
                if(data.barThickness) document.getElementById('grid-thick').value = data.barThickness;
                if(data.fontScale) { fontScale=data.fontScale; document.getElementById('font-size-slider').value=data.fontScale; document.documentElement.style.setProperty('--font-size-base', fontScale+'px'); }
                if(data.fontSizeCC) {
                    fontSizeCC=data.fontSizeCC; document.getElementById('cc-size-slider').value=data.fontSizeCC;
                    document.querySelectorAll('.cc-val-big').forEach(el => el.style.fontSize = fontSizeCC + 'px');
                }

                if(data.crtOpacity) {
                    const el = document.getElementById('crt-slider');
                    el.value = data.crtOpacity;
                    el.dispatchEvent(new Event('input'));
                }

                if(data.channelMaskNotes) {
                    channelMaskNotes = data.channelMaskNotes;
                    channelMaskNotes.forEach((v, i) => {
                        const cb = document.getElementById(`ch-filter-container-notes-mask-${i}`);
                        if(cb) cb.checked = v;
                    });
                }

                if(data.channelMaskCC) {
                    channelMaskCC = data.channelMaskCC;
                    channelMaskCC.forEach((v, i) => {
                        const cb = document.getElementById(`ch-filter-container-cc-mask-${i}`);
                        if(cb) cb.checked = v;
                    });
                }

                if(data.direction) { direction=data.direction; document.getElementById('sel-direction').value=data.direction; document.getElementById('sel-direction').dispatchEvent(new Event('change')); }
                if(data.sidebarPos) { document.getElementById('sel-sidebar-pos').value=data.sidebarPos; document.getElementById('sel-sidebar-pos').dispatchEvent(new Event('change')); }
                if(data.ccScrollDir) { ccScrollDir=data.ccScrollDir; document.getElementById('sel-cc-dir').value=data.ccScrollDir; }

                if(data.trailsOnGrid !== undefined) { setChk('chk-trails-grid', data.trailsOnGrid); }

                if(data.showPGM !== undefined) setChk('chk-show-pgm', data.showPGM);
                if(data.freshPGM !== undefined) setChk('chk-fresh-pgm', data.freshPGM);
                if(data.freshLabels !== undefined) setChk('chk-fresh-labels', data.freshLabels);
                if(data.labelSize !== undefined) { labelSize=data.labelSize; document.getElementById('lbl-size-slider').value=data.labelSize; }
                if(data.labelColorMode !== undefined) { labelColorMode=data.labelColorMode; document.getElementById('sel-lbl-col').value=data.labelColorMode; }
                if(data.overlaySmooth !== undefined) { overlaySmooth=data.overlaySmooth; document.getElementById('ovl-smooth-slider').value=data.overlaySmooth; }
                if(data.overlayThick !== undefined) { overlayThick=data.overlayThick; document.getElementById('ovl-thick-slider').value=data.overlayThick; }
                if(data.overlayTrails !== undefined) setChk('chk-ovl-trail', data.overlayTrails);

                if(data.ccOpacity !== undefined) { ccOpacity=data.ccOpacity; document.getElementById('cc-opac-slider').value=data.ccOpacity; }
                if(data.ccGlow !== undefined) setChk('chk-cc-glow', data.ccGlow);

                if(data.ccLabels) {
                    for (const [id, lbl] of Object.entries(data.ccLabels)) {
                        const mon = ccMonitors.get(id);
                        if(mon) {
                            mon.label = lbl;
                            mon.element.querySelector('.cc-name').innerText = lbl;
                            mon.element.querySelector('.cc-bg-label').innerText = lbl;
                        }
                    }
                }

                updateTimeSig();
            } catch(err) { console.error(err); alert("Invalid Config File"); }
        };
        reader.readAsText(file);
    }

    function updateTimeSig() {
        ticksPerBar = Math.round((4 / sigDen) * sigNum * CONFIG.PPQN);
        barTickCounter = 0;
    }

    function updateFont(val) {
        // Set dropdown
        const dd = document.getElementById('sel-font');
        if(dd.value !== val) dd.value = val;

        const r = document.documentElement.style;
        let stack = "sans-serif";

        if(val==='tech') stack = "'Rajdhani', sans-serif";
        else if(val==='hacker') stack = "'VT323', monospace";
        else if(val==='gory') stack = "'Nosifer', cursive";
        else if(val==='elegant') stack = "'Playfair Display', serif";
        else if(val==='scifi') stack = "'Orbitron', sans-serif";

        currentFontStack = stack;
        r.setProperty('--font-stack', stack);
    }

    function resize() {
        const vCont = document.getElementById('visualizer-container');
        mainCanvas.width = vCont.offsetWidth;
        mainCanvas.height = vCont.offsetHeight;
        overlayCanvas.width = vCont.offsetWidth;
        overlayCanvas.height = vCont.offsetHeight;

        if (direction === 'down' || direction === 'up') {
            pianoCanvas.width = vCont.offsetWidth;
            pianoCanvas.height = 30;
        } else {
            pianoCanvas.width = 40;
            pianoCanvas.height = vCont.offsetHeight;
        }
    }

    function getNoteColor(note, ch) {
        if (currentTheme === 'chernobyl') return '#00ffff';
        if (colorMode === 'channel') return THEMES[currentTheme].ch[ch];
        if (colorMode === 'octave') {
            const octave = Math.floor(note / 12);
            const PAL = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#FFFFFF', '#FF00FF', '#00FFFF'];
            return PAL[octave % PAL.length];
        }
        if (colorMode === 'root') return THEMES[currentTheme].ch[note % 12];
        if (colorMode === 'random') return randomPaletteNotes[ch];
        return '#fff';
    }

    function getCCColor(ch, cc) {
        if(ccColorMode === 'match') return THEMES[currentTheme].ch[ch];
        if(ccColorMode === 'white') return '#ffffff';
        if(ccColorMode === 'random') return randomPaletteCC[ch];

        // Check if it's a theme name
        if(THEMES[ccColorMode]) {
            return THEMES[ccColorMode].ch[ch];
        }
        return THEMES[currentTheme].ch[ch];
    }

    async function initMIDI() {
        const sel = document.getElementById('midi-input');
        if (!navigator.requestMIDIAccess) {
            sel.innerHTML = '<option>NO BROWSER SUPPORT</option>';
            return;
        }
        try {
            midiAccess = await navigator.requestMIDIAccess();
            midiAccess.onstatechange = refreshInputs;
            refreshInputs();
        } catch(e){
            console.error(e);
            sel.innerHTML = '<option>ACCESS DENIED (RETRY)</option>';
        }
    }

    function refreshInputs() {
        const sel = document.getElementById('midi-input');
        sel.innerHTML = '';
        const inputs = Array.from(midiAccess.inputs.values());
        if(inputs.length===0) sel.innerHTML = '<option>NO DEVICES FOUND</option>';
        else {
            const d = document.createElement('option'); d.text = "-- SELECT DEVICE --"; sel.appendChild(d);
            inputs.forEach(i => {
                const o = document.createElement('option'); o.value = i.id; o.text = i.name; sel.appendChild(o);
            });
        }
        if(selectedInputId) sel.value = selectedInputId;
    }

    document.getElementById('midi-input').addEventListener('change', e => {
        if(selectedInputId && midiAccess.inputs.has(selectedInputId))
            midiAccess.inputs.get(selectedInputId).onmidimessage = null;
        selectedInputId = e.target.value;
        const input = midiAccess.inputs.get(selectedInputId);
        if(input) input.onmidimessage = handleMsg;
    });

    function handleMsg(msg) {
        const [status, d1, d2] = msg.data;
        const cmd = status >> 4;
        const ch = status & 0xf;

        if (status === 0xF8) { handleClock(); return; }
        if (status === 0xFA) { setTransport('PLAY', '#00ff41'); return; }
        if (status === 0xFB) { setTransport('CONT', '#ffff00'); return; }
        if (status === 0xFC) { setTransport('STOP', '#ff0055'); resetClock(); return; }

        if (status >= 0xF8) return;

        const now = performance.now();

        // Channel filtering logic
        // PGM Change (0xC0)
        if (cmd === 12) {
            // Program Change has only 1 data byte usually (d1)
            // It applies to a channel, so filter by Note Mask (closest fit for "events")?
            // Or CC Mask? Usually PGM is control. Let's use CC mask.
            if(channelMaskCC[ch] === false) return;

            fallingObjects.push({
                 type: 'pgm',
                 val: d1,
                 ch: ch,
                 pos: 0,
                 len: 2, // thin line
                 timeDropped: now
            });
            flashCh(ch, '#FFF', true);
            return;
        }

        if (cmd === 9 && d2 > 0) {
            if (channelMaskNotes[ch] === false) return;
            const col = getNoteColor(d1, ch);
            activeNotes.set(`${ch}-${d1}`, {
                note: d1, ch, vel: d2, start: now,
                color: col
            });
            flashCh(ch, col);
        }
        else if (cmd === 8 || (cmd === 9 && d2 === 0)) {
            const id = `${ch}-${d1}`;
            if (activeNotes.has(id)) {
                const n = activeNotes.get(id);
                const duration = now - n.start;
                const len = noteSpeed * (duration / 16.66);
                fallingObjects.push({
                    type: 'note', note: n.note,
                    pos: 0, len: len,
                    color: n.color,
                    timeDropped: now
                });
                activeNotes.delete(id);
            }
        }
        else if (cmd === 11) {
            if (channelMaskCC[ch] === false) return;
            handleCC(ch, d1, d2);
            flashCh(ch, null, true);
        }
    }

    function setTransport(txt, color) {
        const el = document.getElementById('transport-val');
        el.innerText = txt;
        el.style.color = color;
    }

    function resetClock() {
        clockTicks = 0; barTickCounter = 0;
    }

    function flashCh(ch, color, isCC=false) {
        const el = chIndicators[ch];
        if(!el) return;

        if(isCC) {
            el.style.backgroundColor = 'var(--data-color)';
            el.style.color = '#000';
        } else {
            el.style.backgroundColor = color;
            el.style.color = '#000';
            el.style.boxShadow = `0 0 8px ${color}`;
        }
        setTimeout(() => {
            el.style.backgroundColor = '';
            el.style.color = '';
            el.style.boxShadow = '';
        }, 100);
    }

    function handleClock() {
        const now = performance.now();
        lastActiveClock = now;

        if (clockTicks % 24 === 0) {
            const dot = document.getElementById('clock-dot');
            dot.classList.add('beat');
            setTimeout(() => dot.classList.remove('beat'), 100);
        }

        if (lastClockTime > 0) {
            const delta = now - lastClockTime;
            if (delta > 2 && delta < 200) {
                tickHistory.push(delta);
                if(tickHistory.length > 192) tickHistory.shift();

                if(clockTicks % 24 === 0) {
                    const avgDelta = tickHistory.reduce((a,b)=>a+b,0) / tickHistory.length;
                    const bpm = 60000 / (avgDelta * 24);
                    document.getElementById('bpm-val').innerText = bpm.toFixed(1);
                }
            }
        }
        lastClockTime = now;

        if (showBarLines && barTickCounter >= ticksPerBar) {
            fallingObjects.push({ type: 'grid', pos: 0, isBar: true, timeDropped: now });
            barTickCounter = 0;
            if(labelPerBar) labeledPitches.clear(); // Reset labels per bar
        }

        const beatInterval = CONFIG.PPQN;
        if (showGrid && clockTicks % beatInterval === 0) {
            if (barTickCounter !== 0) {
                fallingObjects.push({ type: 'grid', pos: 0, isBar: false, timeDropped: now });
            }
        }

        clockTicks++;
        barTickCounter++;
    }

    function handleCC(ch, cc, val) {
        const id = `${ch}-${cc}`;
        if(hiddenCCs.has(id)) return;

        let mon = ccMonitors.get(id);
        const cont = document.getElementById('cc-container');
        const chColor = THEMES[currentTheme].ch[ch];
        const valFont = "'Share Tech Mono', monospace";

        if (!mon) {
            if(ccMonitors.size === 0 && (cont.children.length === 0 || cont.children[0]?.innerText.includes("NO SIGNAL"))) cont.innerHTML = '';

            const el = document.createElement('div');
            el.className = 'cc-widget';
            el.draggable = true;
            el.dataset.id = id;
            el.dataset.ch = ch;
            el.dataset.cc = cc;

            el.innerHTML = `
                <div class="cc-meta">
                    <div style="display:flex; gap:4px; font-size:10px; font-weight:bold; align-items:center; width:100%;">
                        <span style="color:#666">CH</span><span style="color:${chColor}">${ch+1}</span>
                        <span style="color:#666">CC</span><span style="color:${chColor}">${cc}</span>
                        <div class="cc-pin-btn" title="Pin Graph"></div>
                    </div>
                    <span class="cc-name" style="font-size:10px; opacity:0.7;"></span>
                </div>
                <div class="cc-val-big" style="font-family:${valFont}; font-size:${fontSizeCC}px; color:var(--data-color);">${val}</div>
                <div class="cc-graph-container">
                    <div class="cc-bg-label"></div>
                    <canvas></canvas>
                </div>
            `;

            const pinBtn = el.querySelector('.cc-pin-btn');
            pinBtn.style.pointerEvents = "auto"; // Ensure clickability
            el.querySelector('.cc-meta').style.pointerEvents = "auto"; // Enable meta clicks if needed, but keep name safe

            pinBtn.onclick = (e) => {
                e.stopPropagation();
                mon.pinned = !mon.pinned;
                pinBtn.classList.toggle('active', mon.pinned);
            };

            // Rename only on graph click
            el.querySelector('.cc-graph-container').onclick = () => {
                const name = prompt("Rename CC Graph:", mon.label || `CH${ch+1} CC${cc}`);
                if (name) {
                    mon.label = name.toUpperCase();
                    persistentLabels.set(id, mon.label);
                    el.querySelector('.cc-name').innerText = mon.label;
                    el.querySelector('.cc-bg-label').innerText = mon.label;
                }
            };

            el.oncontextmenu = (e) => {
                e.preventDefault();
                hiddenCCs.add(id);
                el.classList.add('hidden');
            };

            el.ondragstart = (e) => {
                e.dataTransfer.setData('text/plain', id);
            };

            const children = Array.from(cont.children);
            let inserted = false;
            for(let child of children) {
                const cCh = parseInt(child.dataset.ch);
                const cCc = parseInt(child.dataset.cc);
                if (!isNaN(cCh) && (ch < cCh || (ch === cCh && cc < cCc))) {
                    cont.insertBefore(el, child);
                    inserted = true;
                    break;
                }
            }
            if(!inserted) cont.appendChild(el);

            const cvs = el.querySelector('canvas');
            cvs.width = ccScale;
            cvs.height = 30;

            // Restore persistent label if exists
            const savedLabel = persistentLabels.get(id) || '';
            if(savedLabel) {
                el.querySelector('.cc-name').innerText = savedLabel;
                el.querySelector('.cc-bg-label').innerText = savedLabel;
            }

            mon = {
                ch, cc, val,
                history: [],
                element: el,
                valEl: el.querySelector('.cc-val-big'),
                ctx: cvs.getContext('2d'),
                w: ccScale, h: 30,
                color: getCCColor(ch, cc),
                lastUpdate: performance.now(),
                label: savedLabel,
                pinned: false,
                needsUpdate: false // Initialize the flag
            };

            ccMonitors.set(id, mon);
            mon.history.push({t: performance.now(), v: val});

            const ro = new ResizeObserver(() => {
                const rect = el.querySelector('.cc-graph-container').getBoundingClientRect();
                if(rect.width > 0) {
                    cvs.width = rect.width; cvs.height = rect.height;
                    mon.w = cvs.width; mon.h = cvs.height;
                }
            });
            ro.observe(el.querySelector('.cc-graph-container'));
        } else {
            mon.val = val;
            mon.lastUpdate = performance.now();
            mon.needsUpdate = true; // Flag for update in render loop

            mon.history.push({t: performance.now(), v: val});

            const timeWindow = 60000; // Increased history
            while(mon.history.length > 0 && mon.history[0].t < performance.now() - timeWindow) {
                mon.history.shift();
            }
        }
    }

    function drawCCGraphs(now) {
        const windowSize = 5000;

        ccMonitors.forEach(mon => {
            // --- Deferred DOM Update ---
            if (mon.needsUpdate) {
                mon.valEl.innerText = mon.val;

                // Also update color-dependent parts here to keep it synced
                const newColor = getCCColor(mon.ch, mon.cc);
                mon.color = newColor;
                const meta = mon.element.querySelectorAll('.cc-meta span');
                if(meta.length >= 4) {
                    meta[1].style.color = newColor;
                    meta[3].style.color = newColor;
                }

                mon.needsUpdate = false;
            }
            // -------------------------

            const ctx = mon.ctx;
            const w = mon.w;
            const h = mon.h;

            // Use the already updated color
            const col = mon.color;

            ctx.clearRect(0,0,w,h);
            ctx.strokeStyle = col;
            ctx.lineWidth = 2;
            ctx.beginPath();

            const points = [...mon.history];
            points.push({t: now, v: mon.val});

            if (points.length === 0) return;

            const startTime = now - windowSize;
            let firstPoint = true;

            for(let i=0; i<points.length; i++) {
                const p = points[i];
                let x;
                if (ccScrollDir === 'left') {
                    x = ((p.t - startTime) / windowSize) * w;
                } else {
                    x = ((now - p.t) / windowSize) * w;
                }
                const y = h - (p.v / 127) * h;

                if(firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    const prevP = points[i-1];
                    let prevX;
                    if (ccScrollDir === 'left') prevX = ((prevP.t - startTime) / windowSize) * w;
                    else prevX = ((now - prevP.t) / windowSize) * w;
                    const prevY = h - (prevP.v / 127) * h;

                    ctx.lineTo(x, prevY);
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        });
    }

    function renameCC(id) {
        // Replaced by inline onclick
    }

    window.clearCC = function() {
        // Only clear history, do not destroy widgets
        ccMonitors.forEach(mon => {
            mon.history = [];
        });
    }

    function drawNoteShape(ctx, x, y, w, h, type) {
        if (type === 'bar') {
            ctx.fillRect(x, y, w, h);
        } else if (type === 'bubble') {
            ctx.beginPath();
            const r = Math.min(w, h)/2;
            if(r < 1) { ctx.fillRect(x,y,w,h); return; }
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();
        } else if (type === 'tear') {
            ctx.beginPath();
            // Direction dependent teardrop?
            if (direction === 'down' || direction === 'right') {
                 ctx.moveTo(x, y);
                 ctx.lineTo(x+w, y);
                 ctx.lineTo(x+w/2, y+h);
                 ctx.fill();
            } else {
                 ctx.moveTo(x+w/2, y);
                 ctx.lineTo(x+w, y+h);
                 ctx.lineTo(x, y+h);
                 ctx.fill();
            }
        } else if (type === 'hex') {
             ctx.beginPath();
             const p = 0.2;
             if (direction === 'down' || direction === 'up') {
                 ctx.moveTo(x, y + h*p);
                 ctx.lineTo(x + w/2, y);
                 ctx.lineTo(x + w, y + h*p);
                 ctx.lineTo(x + w, y + h*(1-p));
                 ctx.lineTo(x + w/2, y + h);
                 ctx.lineTo(x, y + h*(1-p));
             } else {
                 ctx.moveTo(x + w*p, y);
                 ctx.lineTo(x + w*(1-p), y);
                 ctx.lineTo(x + w, y + h/2);
                 ctx.lineTo(x + w*(1-p), y + h);
                 ctx.lineTo(x + w*p, y + h);
                 ctx.lineTo(x, y + h/2);
             }
             ctx.fill();
        } else {
             ctx.fillRect(x, y, w, h);
        }
    }

    let lastFrameTime = performance.now();
    function loop() {
        requestAnimationFrame(loop);

        const now = performance.now();
        const dt = now - lastFrameTime;
        lastFrameTime = now;

        const moveDist = noteSpeed * (dt / 16.66);

        if (now - lastActiveClock > 2000 && lastActiveClock !== 0) {
            document.getElementById('bpm-val').innerText = "NO CLOCK";
            lastActiveClock = 0;
        }

        // CC Render
        drawCCGraphs(now);

        const visKeys = 128 / zoomLevel;
        const maxStart = 128 - visKeys;
        const startKey = (panPercent / 100) * maxStart;
        const endKey = startKey + visKeys;
        const keyW = mainCanvas.width / visKeys;

        mainCtx.save();
        // TRAILS: Fade to BG color instead of black
        if (persistence > 0) {
            const bg = getComputedStyle(document.body).getPropertyValue('--bg-color');
            mainCtx.globalAlpha = (1 - persistence);
            mainCtx.fillStyle = bg;
            mainCtx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
            mainCtx.globalAlpha = 1.0;
        } else {
            mainCtx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
            const bg = getComputedStyle(document.body).getPropertyValue('--bg-color');
            mainCtx.fillStyle = bg;
            mainCtx.fillRect(0,0,mainCanvas.width, mainCanvas.height);
        }
        mainCtx.restore();

        // Clear Overlay Canvas every frame
        overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);

        const isVertical = (direction === 'down' || direction === 'up');

        if (isVertical) {
            drawVertical(startKey, endKey, visKeys, moveDist, keyW);
        } else {
            drawHorizontal(startKey, endKey, visKeys, moveDist, keyW);
        }
    }

    function drawVertical(startKey, endKey, visKeys, moveDist, keyW) {
        const thickW = keyW * (noteThickness / 100);
        const thickOffset = (keyW - thickW) / 2;

        // PIANO
        if(showPiano) {
            pianoCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--panel-bg');
            pianoCtx.fillRect(0,0, pianoCanvas.width, pianoCanvas.height);

            for(let i=Math.floor(startKey); i<endKey; i++) {
                const x = Math.floor((i-startKey)*keyW);
                const w = Math.ceil(keyW);
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);
                const noteName = CONFIG.NOTE_NAMES[i%12];

                pianoCtx.fillStyle = isBlack ? '#222' : '#888';
                pianoCtx.fillRect(x, isBlack?0:10, w-1, isBlack?18:20);

                // C-Line Labels Adjacent (Under) Piano Roll
                if(noteName === "C") {
                    // NO LABELS INSIDE KEYS
                    // Draw Label on MAIN CANVAS at Top (since piano is top strip)
                    mainCtx.save();
                    mainCtx.fillStyle = 'rgba(255,255,255,0.5)';
                    mainCtx.font = `bold ${fontScale}px ${currentFontStack}`; // Use Dynamic Font
                    const octave = Math.floor(i/12) - 1;
                    // Position at top of visualizer
                    const lblY = (direction === 'down') ? 15 : mainCanvas.height - 5;
                    mainCtx.fillText("C"+octave, x + 2, lblY);
                    mainCtx.restore();
                }
            }
        }

        // C-LINES
        if (showCLines) {
            mainCtx.save();
            mainCtx.lineWidth = 1;
            mainCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            mainCtx.font = `bold ${fontScale*1.5}px ${currentFontStack}`; // Use Dynamic Font
            mainCtx.fillStyle = 'rgba(255,255,255,0.1)';
            for(let i=Math.floor(startKey); i<endKey; i++) {
                if (i % 12 === 0) {
                     const x = Math.floor((i-startKey)*keyW);
                     mainCtx.beginPath();
                     mainCtx.moveTo(x, 0); mainCtx.lineTo(x, mainCanvas.height);
                     mainCtx.stroke();
                     // If piano hidden, draw labels here too?
                     // Already covered by piano logic above? No, if piano off, that loop doesn't run.
                     if(!showPiano) {
                         mainCtx.fillText("C" + (Math.floor(i/12)-1), x + 5, mainCanvas.height - 20);
                     }
                }
            }
            mainCtx.restore();
        }

        // FALLING
        const now = performance.now(); // For Overlay CC
        const windowSize = 5000;

        for(let i=fallingObjects.length-1; i>=0; i--) {
            const o = fallingObjects[i];
            o.pos += moveDist;

            if(o.pos > mainCanvas.height + o.len) { fallingObjects.splice(i,1); continue; }

            if(o.type === 'grid') {
                // Render to MainCtx (trailed) OR OverlayCtx (fresh)
                const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;
                targetCtx.strokeStyle = o.isBar ? getComputedStyle(document.body).getPropertyValue('--grid-bar') : getComputedStyle(document.body).getPropertyValue('--grid-beat');
                targetCtx.lineWidth = o.isBar ? barThickness : 1;
                targetCtx.beginPath();

                if (direction === 'down') {
                    targetCtx.moveTo(0, o.pos); targetCtx.lineTo(mainCanvas.width, o.pos);
                } else {
                    const y = mainCanvas.height - o.pos;
                    targetCtx.moveTo(0, y); targetCtx.lineTo(mainCanvas.width, y);
                }
                targetCtx.stroke();
                targetCtx.restore();
            }
            else if(o.type === 'pgm') {
                if(!showPGM) continue;
                const targetCtx = freshPGM ? overlayCtx : mainCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;

                // Color by Value (Mod 16) using active palette
                const pgmCol = getNoteColor(o.val, o.val % 16);
                targetCtx.fillStyle = pgmCol;
                targetCtx.globalAlpha = 0.4;

                let py;
                if(direction === 'down') py = o.pos;
                else py = mainCanvas.height - o.pos;

                targetCtx.fillRect(0, py, mainCanvas.width, 4);
                targetCtx.globalAlpha = 1.0;

                targetCtx.font = `bold ${labelSize}px ${currentFontStack}`;
                targetCtx.fillStyle = pgmCol;
                targetCtx.fillText(`PGM ${o.val}`, 10, py - 5);
                targetCtx.restore();
            }
            else if(o.type === 'note') {
                if(o.note < startKey || o.note >= endKey) continue;
                const x = Math.floor((o.note - startKey)*keyW) + thickOffset;

                mainCtx.save();
                if(glowEnabled && glowAmount > 0) {
                    mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : o.color;
                    mainCtx.shadowBlur = glowAmount;
                }
                mainCtx.fillStyle = o.color;

                let ry;
                if (direction === 'down') { ry = o.pos; }
                else { ry = mainCanvas.height - o.pos - o.len; }

                // Draw Shape
                drawNoteShape(mainCtx, x, ry, Math.ceil(thickW), o.len, noteShape);
                mainCtx.restore();

                // Labels
                if(showLabels && keyW > 15) {
                    const alreadyLabeled = labelPerBar && labeledPitches.has(o.note);
                    if (!alreadyLabeled) {
                        const targetCtx = freshLabels ? overlayCtx : mainCtx;
                        targetCtx.save(); targetCtx.shadowBlur=0;
                        targetCtx.fillStyle = (labelColorMode === 'match') ? o.color : '#fff';
                        targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                        // Leading Edge Position
                        let ly;
                        if (direction === 'down') ly = o.pos + o.len + 12; // Bottom
                        else ly = (mainCanvas.height - o.pos - o.len) - 5; // Top

                        targetCtx.fillText(CONFIG.NOTE_NAMES[o.note%12], x+2, ly);
                        targetCtx.restore();

                        if(labelPerBar) labeledPitches.add(o.note);
                    }
                }
            }
        }

        // BIG CC OVERLAY (Vertical)
        if(bigCCs.size > 0) {
            const targetCtx = overlayTrails ? mainCtx : overlayCtx;
            targetCtx.save();

            if(ccGlow) {
                 targetCtx.shadowBlur = 20;
                 // Use white shadow if color is dark? Default to color.
            }

            let idx = 0;
            const laneW = mainCanvas.width / bigCCs.size;

            bigCCs.forEach(id => {
                 const mon = ccMonitors.get(id);
                 if(!mon) return;

                 if(ccGlow) targetCtx.shadowColor = mon.color;

                 targetCtx.strokeStyle = mon.color;
                 targetCtx.lineWidth = overlayThick;
                 targetCtx.globalAlpha = ccOpacity;
                 targetCtx.beginPath();

                 // Ensure we draw to 'now' so static lines persist
                 const points = [...mon.history];
                 // Always push a point at 'now' with last value to fill gap
                 points.push({t: now, v: mon.val});

                 // Collect XY points first for smoothing
                 const coords = [];
                 const xOffset = idx * laneW;

                 for(let i=0; i<points.length; i++) {
                     const p = points[i];
                     const dist = (now - p.t) * (noteSpeed / 16.66);
                     if(dist > mainCanvas.height) continue;

                     let y;
                     if(direction === 'down') y = dist; // 0 is top/now
                     else y = mainCanvas.height - dist; // height is bottom/now

                     const laneCenterX = xOffset + laneW / 2;
                     const scaledWidth = laneW * bigCcGraphScale;
                     const x = laneCenterX - (scaledWidth / 2) + (p.v / 127) * scaledWidth;
                     coords.push({x, y});
                 }

                 if(coords.length >= 2) {
                     if(overlaySmooth > 0 && coords.length > 2) {
                         // Simple Smoothing (Catmull-Rom or Quadratic would be better, but Chaikin/Midpoint is easy)
                         // Just drawing lineTo is linear.
                         // Let's use quadraticCurveTo for simple smoothing
                         targetCtx.moveTo(coords[0].x, coords[0].y);
                         for (let i = 1; i < coords.length - 1; i ++) {
                            const xc = (coords[i].x + coords[i+1].x) / 2;
                            const yc = (coords[i].y + coords[i+1].y) / 2;
                            targetCtx.quadraticCurveTo(coords[i].x, coords[i].y, xc, yc);
                         }
                         // Last point
                         targetCtx.lineTo(coords[coords.length-1].x, coords[coords.length-1].y);
                     } else {
                         targetCtx.moveTo(coords[0].x, coords[0].y);
                         for(let i=1; i<coords.length; i++) targetCtx.lineTo(coords[i].x, coords[i].y);
                     }

                     targetCtx.stroke();
                 }

                 // Label (always fresh/overlay)
                 overlayCtx.save();
                 overlayCtx.fillStyle = mon.color;
                 overlayCtx.font = `bold ${labelSize}px ${currentFontStack}`;

                 const labelY = (direction==='down') ? 35 : mainCanvas.height - 20; // Below piano roll in Down mode (30px piano)
                 overlayCtx.fillText(mon.label || `CC ${mon.cc}`, xOffset + 5, labelY);
                 overlayCtx.restore();

                 idx++;
            });
            targetCtx.restore();
        }

        // ACTIVE
        activeNotes.forEach(n => {
            if(n.note < startKey || n.note >= endKey) return;
            const x = Math.floor((n.note - startKey)*keyW) + thickOffset;
            const duration = performance.now() - n.start;
            const len = noteSpeed * (duration / 16.66);

            mainCtx.save();
            if(glowEnabled && glowAmount > 0) {
                mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : n.color;
                mainCtx.shadowBlur = glowAmount;
            }
            mainCtx.fillStyle = n.color;

            let ry;
            if (direction === 'down') { ry = 0; }
            else { ry = mainCanvas.height - len; }

            drawNoteShape(mainCtx, x, ry, Math.ceil(thickW), len, noteShape);
            mainCtx.restore();

            if(showLabels && keyW > 15) {
                // Active note label
                const alreadyLabeled = labelPerBar && labeledPitches.has(n.note);
                if(!alreadyLabeled) {
                    const targetCtx = freshLabels ? overlayCtx : mainCtx;
                    targetCtx.save(); targetCtx.shadowBlur=0;
                    targetCtx.fillStyle = (labelColorMode === 'match') ? n.color : '#fff';
                    targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                    let ly;
                    if (direction === 'down') ly = len + 12;
                    else ly = (mainCanvas.height - len) - 5;

                    targetCtx.fillText(CONFIG.NOTE_NAMES[n.note%12], x+2, ly);
                    targetCtx.restore();

                    if(labelPerBar) labeledPitches.add(n.note);
                }
            }
        });

        // GRID LANES - Always on Overlay or Main? Usually static grid is best on overlay to avoid smearing
        // But if trailsOnGrid is requested, maybe user wants everything to trail?
        // Let's put Static Grid on Overlay usually, unless trailsOnGrid is specifically requested for all grid elements.
        // For now, let's keep static lanes on Overlay for cleanliness unless Trails requested.

        if(showGrid) {
             const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
             for(let i=Math.floor(startKey); i<endKey; i++) {
                const x = Math.floor((i-startKey)*keyW);
                const w = Math.ceil(keyW);

                targetCtx.save(); targetCtx.shadowBlur=0;
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);
                targetCtx.fillStyle = isBlack ? 'rgba(255,255,255,0.03)' : 'transparent';
                targetCtx.fillRect(x, 0, w, mainCanvas.height);
                targetCtx.strokeStyle = 'rgba(255,255,255,0.05)';
                targetCtx.beginPath(); targetCtx.moveTo(x,0); targetCtx.lineTo(x,mainCanvas.height); targetCtx.stroke();
                targetCtx.restore();
             }
        }
    }

    function drawHorizontal(startKey, endKey, visKeys, moveDist, keyW) {
        const keyH = mainCanvas.height / visKeys;
        const thickH = keyH * (noteThickness / 100);
        const thickOffset = (keyH - thickH) / 2;

        // PIANO
        if(showPiano) {
            pianoCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--panel-bg');
            pianoCtx.fillRect(0,0, pianoCanvas.width, pianoCanvas.height);

            for(let i=Math.floor(startKey); i<endKey; i++) {
                const y = mainCanvas.height - (i - startKey + 1) * keyH;
                const h = Math.ceil(keyH);
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);
                const noteName = CONFIG.NOTE_NAMES[i%12];

                pianoCtx.fillStyle = isBlack ? '#222' : '#888';
                pianoCtx.fillRect(isBlack?0:0, y, isBlack?20:38, h-1);

                // Labels
                pianoCtx.fillStyle = '#fff';
                pianoCtx.font = `bold ${fontScale*0.9}px ${currentFontStack}`;

                if(noteName === "C") {
                    const octave = Math.floor(i/12) - 1;
                    pianoCtx.fillText("C"+octave, 22, y + h - 4);
                }
                else if(showLabels || (!isBlack && keyH > 12)) {
                    if(keyH > 12) pianoCtx.fillText(noteName, 22, y + h - 4);
                }
            }
        }

        // C-LINES
        if(showCLines && !showPiano) {
             for(let i=Math.floor(startKey); i<endKey; i++) {
                 if(i%12===0) {
                    const y = mainCanvas.height - (i - startKey + 1) * keyH;
                    const h = Math.ceil(keyH);
                    mainCtx.save(); mainCtx.strokeStyle='rgba(255,255,255,0.1)';
                    mainCtx.beginPath(); mainCtx.moveTo(0,y+h); mainCtx.lineTo(mainCanvas.width,y+h); mainCtx.stroke();
                    mainCtx.fillStyle = 'rgba(255,255,255,0.5)';
                    mainCtx.font = `bold ${fontScale}px ${currentFontStack}`; // Dynamic
                    const lblX = (direction === 'right') ? 5 : mainCanvas.width - 25;
                    mainCtx.fillText("C"+(Math.floor(i/12)-1), lblX, y + h - 5);
                    mainCtx.restore();
                 }
             }
        }

        // FALLING
        const now = performance.now();

        for(let i=fallingObjects.length-1; i>=0; i--) {
            const o = fallingObjects[i];
            o.pos += moveDist;

            if(o.pos > mainCanvas.width + o.len) { fallingObjects.splice(i,1); continue; }

            if(o.type === 'grid') {
                const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;
                targetCtx.strokeStyle = o.isBar ? getComputedStyle(document.body).getPropertyValue('--grid-bar') : getComputedStyle(document.body).getPropertyValue('--grid-beat');
                targetCtx.lineWidth = o.isBar ? barThickness : 1;
                targetCtx.beginPath();

                if (direction === 'right') {
                    targetCtx.moveTo(o.pos, 0); targetCtx.lineTo(o.pos, mainCanvas.height);
                } else { // LEFT
                    const x = mainCanvas.width - o.pos;
                    targetCtx.moveTo(x, 0); targetCtx.lineTo(x, mainCanvas.height);
                }
                targetCtx.stroke();
                targetCtx.restore();
            }
            else if(o.type === 'pgm') {
                if(!showPGM) continue;
                const targetCtx = freshPGM ? overlayCtx : mainCtx;
                targetCtx.save(); targetCtx.shadowBlur = 0;

                const pgmCol = getNoteColor(o.val, o.val % 16);
                targetCtx.fillStyle = pgmCol;
                targetCtx.globalAlpha = 0.4;

                let px;
                if(direction === 'right') px = o.pos;
                else px = mainCanvas.width - o.pos;

                targetCtx.fillRect(px, 0, 4, mainCanvas.height);
                targetCtx.globalAlpha = 1.0;

                targetCtx.font = `bold ${labelSize}px ${currentFontStack}`;
                targetCtx.fillStyle = pgmCol;
                targetCtx.fillText(`PGM ${o.val}`, px + 5, 20);
                targetCtx.restore();
            }
            else if(o.type === 'note') {
                if(o.note < startKey || o.note >= endKey) continue;
                const y = mainCanvas.height - (o.note - startKey + 1) * keyH + thickOffset;

                mainCtx.save();
                if(glowEnabled && glowAmount > 0) {
                    mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : o.color;
                    mainCtx.shadowBlur = glowAmount;
                }
                mainCtx.fillStyle = o.color;

                let rx;
                if (direction === 'right') { rx = 0; }
                else { rx = mainCanvas.width - o.pos - o.len; }

                drawNoteShape(mainCtx, rx, y, o.len, Math.ceil(thickH), noteShape);
                mainCtx.restore();

                if(showLabels && keyH > 15) {
                    const alreadyLabeled = labelPerBar && labeledPitches.has(o.note);
                    if(!alreadyLabeled) {
                        const targetCtx = freshLabels ? overlayCtx : mainCtx;
                        targetCtx.save(); targetCtx.shadowBlur=0;
                        targetCtx.fillStyle = (labelColorMode === 'match') ? o.color : '#fff';
                        targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                        let lx;
                        if (direction === 'right') lx = o.pos + o.len + 5;
                        else lx = (mainCanvas.width - o.pos - o.len) - 15;

                        targetCtx.fillText(CONFIG.NOTE_NAMES[o.note%12], lx, y + keyH/2 + 4);
                        targetCtx.restore();
                        if(labelPerBar) labeledPitches.add(o.note);
                    }
                }
            }
        }

        // BIG CC OVERLAY (Horizontal)
        if(bigCCs.size > 0) {
            const targetCtx = overlayTrails ? mainCtx : overlayCtx;
            targetCtx.save();

            if(ccGlow) {
                 targetCtx.shadowBlur = 20;
            }

            let idx = 0;
            const laneH = mainCanvas.height / bigCCs.size;

            bigCCs.forEach(id => {
                 const mon = ccMonitors.get(id);
                 if(!mon) return;

                 if(ccGlow) targetCtx.shadowColor = mon.color;

                 targetCtx.strokeStyle = mon.color;
                 targetCtx.lineWidth = overlayThick;
                 targetCtx.globalAlpha = ccOpacity;
                 targetCtx.beginPath();

                 const points = [...mon.history];
                 points.push({t: now, v: mon.val});

                 const coords = [];
                 const yOffset = idx * laneH;

                 for(let i=0; i<points.length; i++) {
                     const p = points[i];
                     const dist = (now - p.t) * (noteSpeed / 16.66);
                     if(dist > mainCanvas.width) continue;

                     let x;
                     if(direction === 'right') x = dist;
                     else x = mainCanvas.width - dist;

                    // Corrected Scaling Logic for Horizontal
                    const laneCenterY = yOffset + laneH / 2;
                    const scaledHeight = laneH * bigCcGraphScale;
                    const y = laneCenterY + (scaledHeight / 2) - (p.v / 127) * scaledHeight;
                    coords.push({x, y});
                }

                 if(coords.length >= 2) {
                     if(overlaySmooth > 0 && coords.length > 2) {
                         targetCtx.moveTo(coords[0].x, coords[0].y);
                         for (let i = 1; i < coords.length - 1; i ++) {
                            const xc = (coords[i].x + coords[i+1].x) / 2;
                            const yc = (coords[i].y + coords[i+1].y) / 2;
                            targetCtx.quadraticCurveTo(coords[i].x, coords[i].y, xc, yc);
                         }
                         targetCtx.lineTo(coords[coords.length-1].x, coords[coords.length-1].y);
                     } else {
                         targetCtx.moveTo(coords[0].x, coords[0].y);
                         for(let i=1; i<coords.length; i++) targetCtx.lineTo(coords[i].x, coords[i].y);
                     }
                     targetCtx.stroke();
                 }

                 // Label
                 overlayCtx.save();
                 overlayCtx.fillStyle = mon.color;
                 overlayCtx.font = `bold ${labelSize}px ${currentFontStack}`;

                 const labelX = (direction==='right') ? 20 : mainCanvas.width - 100;
                 overlayCtx.fillText(mon.label || `CC ${mon.cc}`, labelX, yOffset + 20);
                 overlayCtx.restore();

                 idx++;
            });
            targetCtx.restore();
        }

        // ACTIVE
        activeNotes.forEach(n => {
            if(n.note < startKey || n.note >= endKey) return;
            const y = mainCanvas.height - (n.note - startKey + 1) * keyH + thickOffset;
            const duration = performance.now() - n.start;
            const len = noteSpeed * (duration / 16.66);

            mainCtx.save();
            if(glowEnabled && glowAmount > 0) {
                mainCtx.shadowColor = (currentTheme === 'chernobyl') ? '#00FFFF' : n.color;
                mainCtx.shadowBlur = glowAmount;
            }
            mainCtx.fillStyle = n.color;

            let rx;
            if (direction === 'right') { rx = 0; }
            else { rx = mainCanvas.width - len; }

            drawNoteShape(mainCtx, rx, y, len, Math.ceil(thickH), noteShape);
            mainCtx.restore();

            if(showLabels && keyH > 15) {
                const alreadyLabeled = labelPerBar && labeledPitches.has(n.note);
                if(!alreadyLabeled) {
                    const targetCtx = freshLabels ? overlayCtx : mainCtx;
                    targetCtx.save(); targetCtx.shadowBlur=0;
                    targetCtx.fillStyle = (labelColorMode === 'match') ? n.color : '#fff';
                    targetCtx.font=`bold ${labelSize}px ${currentFontStack}`;

                    let lx;
                    if (direction === 'right') lx = len + 5;
                    else lx = (mainCanvas.width - len) - 15;

                    targetCtx.fillText(CONFIG.NOTE_NAMES[n.note%12], lx, y + keyH/2 + 4);
                    targetCtx.restore();
                    if(labelPerBar) labeledPitches.add(n.note);
                }
            }
        });

        // GRID LANES
        if(showGrid) {
             const targetCtx = trailsOnGrid ? mainCtx : overlayCtx;
             for(let i=Math.floor(startKey); i<endKey; i++) {
                const y = mainCanvas.height - (i - startKey + 1) * keyH;
                const h = Math.ceil(keyH);
                const isBlack = CONFIG.BLACK_KEYS.includes(i%12);

                targetCtx.save(); targetCtx.shadowBlur=0;
                targetCtx.fillStyle = isBlack ? 'rgba(255,255,255,0.03)' : 'transparent';
                targetCtx.fillRect(0, y, mainCanvas.width, h);
                targetCtx.strokeStyle = 'rgba(255,255,255,0.05)';
                targetCtx.beginPath(); targetCtx.moveTo(0,y+h); targetCtx.lineTo(mainCanvas.width,y+h); targetCtx.stroke();
                targetCtx.restore();
             }
        }
    }

    init();
</script>
</body>
</html>